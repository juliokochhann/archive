;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 7.20
;// License Type  : Lite License (Unregistered)
;// Limitations   : PIC12,PIC16 max code size:2048 words, max RAM banks:2, Non commercial use only
;/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// LCD with HD44780 drive chip
////////////////////////////////////////////////////////////////////////////
// Author(s): David Hobday, Pavel Baranov
// Date 15 November 2004
//
// Copyright(C) 2004-2010 Pavel Baranov
// Copyright(C) 2004-2010 David Hobday
// Copyright(C) 2004 Andrew Smallridge
//
//
// How to use - by David Hobday
// ============================
// Remember when using LCD in 4 bit mode you must connect to the LCDs DB4-DB7 pins.
//
// *** For a list of functions, see the END of this file.
//
// The time delays used in the code should mean that it will work on PIC18 with 
// 40MHz clock without any changes.
//
// The example below (which would work on a PIC16F84) operates the display 
// in 4bit mode and requires the following connections:
// RS  to RA3
// R/W to RA2
// E   to RA1
// DB0 to None
// DB1 to None
// DB2 to None
// DB3 to None
// DB4 to RB4
// DB5 to RB5
// DB6 to RB6
// DB7 to RB7
//
//
// Add the following after #include <system.h> in you source file:
//
//#define LCD_ARGS 	2,	/* Interface type: mode 0 = 8bit, 1 = 4bit(low nibble), 2 = 4bit(upper nibble) */ \
//		1, 				/* Use busy signal: 1 = use busy, 0 = use time delays */\
//		PORTB, TRISB, 	/* Data port and data port tris register */ \
//		PORTA, TRISA, 	/* Control port and control port tris register */ \
//		3,				/* Bit number of control port is connected to RS */ \
//		2,				/* Bit number of control port is connected to RW */ \
//		1 				/* Bit number of control port is connected to Enable */
//
//#include <lcd_driver.h> // include the LCD template code
//
//
// Revisions
// =========
//
// V1.10 David Hobday 03/03/2005
// =============================
// 1) Improved documentation in file
// 2) Changed delays to delay_10us for usage on target with clock <= 4MHz
// 3) Changed template to make more friendly and obvious
// 
// V1.11 18/03/2005
// David Hobday
// 1) Fixed operation with PIC18 - template arguments of incorrect type
// 2) Tested with PicDem2Plus board (4MHz PIC16F877/PIC18F452)
// 3) Added lcd_gotoxy function.
// 4) Added option to use display busy bit or time delays
// 5) Added overloaded lprintf function for ROM string
// 6) Added overloaded lprintf function to output numbers supported formats:
//  "%d" - decimal
//  "%X" - hex
//  "%b" - binart
//  example: display binary number six digits, '0' as file character.
//  lprintf( "val:%06b", numb );
// 7) Other improvements/cleanup.
//
//
// V1.11 David Hobday 25/03/2005
// =============================
// 1) Fixed bug with lprintf( "test:%d", 0 ); not printing a 0.
// 2) Added a few more comments in lprintf( const char*, int ) code
// 
//
// V1.12 Jason Sobell 03/07/2005
// =============================
// 1) Fixed display of unsigned integers >32767
//
//
// V1.13 David Hobday 08/07/2005
// =============================
// 1) Removed code that is no longer needed (as val is now unsigned).
// 2) Tweaked Jason Sobell changes a little to reduce code size.
//
// 
// V1.14 David Hobday 11/11/2005
// =============================
// 1) Changed lcd_gotoxy function so that it works as expected with 20 x 4 display
//

////////////////////////////////////////////////////////////////////////////

char writeDelayType;

////////////////////////////////////////////////////////////////////////////
// LCD Commands ( Refer to LCD Data Sheet )
////////////////////////////////////////////////////////////////////////////
#define clear_lcd         		0x01 // Clear Display
#define return_home       		0x02 // Cursor to Home position
#define entry_mode        		0x06 // Normal entry mode
#define entry_mode_rev    		0x04 // Normal entry mode  -reverse direction
#define entry_mode_scroll 		0x07 // - with shift
#define entry_mode_scroll_rev	0x05 // reverse direction

#define system_set_8_bit  		0x38 // 8 bit data mode 2 line ( 5x7 font )
#define system_set_4_bit  		0x28 // 4 bit data mode 2 line ( 5x7 font )
#define system_set_reset  		0x30 // Reset code
#define display_on        		0x0C // Display ON - 2 line mode
#define display_off       		0x08 // Display off
#define set_dd_line1      		0x80 // Line 1 position 1
#define set_dd_line2      		0xC0 // Line 2 position 1
#define set_dd_ram        		0x80 // Line 1 position 1
#define write_data        		0x00 // With RS = 1
#define cursor_on         		0x0E // Switch Cursor ON
#define cursor_off        		0x0C // Switch Cursor OFF
#define cursor_blink_on   		0x0F // Cursor plus blink
#define cursor_shift_right		0x14 // Move cursor right
#define cursor_shift_left 		0x10 // Move cursor left
#define display_shift_right		0x1C // Scroll display right
#define display_shift_left		0x18 // Scroll display left

#define WriteNoDelay	1
#define WriteControlled	0

// Interface type
#define LCD_8_BIT_MODE 0
#define LCD_4_BIT_LO_NIB_MODE 1
#define LCD_4_BIT_HI_NIB_MODE 2

// These macros make susequent code more readable, but can seem a little confusing
#define _LCD_RawWriteNibble LCD_RawWriteNibble	<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_RawWriteNibbleInline  LCD_RawWriteNibbleInline	<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_Read			LCD_Read			<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_WaitForNotBusy	LCD_WaitForNotBusy	<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_Write			LCD_Write			<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_FunctionMode	LCD_FunctionMode	<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_DataMode		LCD_DataMode		<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_RawWrite		LCD_RawWrite		<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>
#define _LCD_ClockOut		LCD_ClockOut		<InterfaceType, UseBusy, DataPort, Data_PortTris, CtrlPort, Ctrl_PortTris, RS, RW, E>

#define _LCD_TEMPL		template <	unsigned char InterfaceType,\
									unsigned char UseBusy,\
									unsigned int DataPort, unsigned int Data_PortTris,\
									unsigned int CtrlPort, unsigned int Ctrl_PortTris,\
									unsigned char RS, unsigned char RW, unsigned char E>

_LCD_TEMPL
inline void LCD_FunctionMode( void )
{
	volatile bit rs@CtrlPort.RS = 0;
}

_LCD_TEMPL
inline void LCD_DataMode( void )
{
	volatile bit rs@CtrlPort.RS = 1;
}


inline void LCD_CycleMakeupDelay()
{
	// Enable cycle time must be > 1000ns total for both reading and writing
	// LCD_SetupDelay + LCD_EnablePulseDelay + LCD_HoldupDelay + LCD_CycleMakeupDelay >= 1000ns
	//       200      +          500         +       100       +          200         >= 1000ns

	// This delay is required to meet the Sharp data sheet total cycle time of > 1000ns
	// @40MHz this is 2 instructions
	asm nop 
	asm nop	
}


inline void LCD_EnablePulseDelay()
{		
	// PWEH > 460ns on Sharp data sheet
	// @40MHz this is 5 instructions
	asm nop 
	asm nop
	asm nop
	asm nop
	asm nop
}

inline void LCD_SetupDelay()
{
	// tAS > 140ns min on Sharp data sheet
	// @40MHz this is 2 instructions
	asm nop 
	asm nop
}

inline void LCD_HoldupDelay()
{
	// tAS > 10ns min on Sharp data sheet
	// @40MHz this is 1 instructions
	asm nop
}



_LCD_TEMPL
char LCD_Read()

{		
	char d; 
	volatile unsigned char data@DataPort, tris@Data_PortTris;
	volatile bit rw@CtrlPort.RW, e@CtrlPort.E;
	
	if( InterfaceType == LCD_4_BIT_HI_NIB_MODE )

	{
		// upper nibble input
		tris |= 0xF0;
		rw = 1; // set reading mode
		// first high nibble	
		LCD_SetupDelay();
		e = 1;
		LCD_EnablePulseDelay();
		d = data & 0xF0; // read data
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
			
		// then low nibble
		LCD_SetupDelay();
		e = 1;
		LCD_EnablePulseDelay();
		d |= data >> 4;
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}


	if( InterfaceType == LCD_4_BIT_LO_NIB_MODE )
	{
		// lower nibble input	
		tris |= 0x0F;
0026  300F  	MOVLW 0x0F
0027  1683  	BSF STATUS, RP0
0028  1303  	BCF STATUS, RP1
0029  0487  	IORWF LCD_Read_00000_1_tris, F

		rw = 1; // set reading mode
002A  1283  	BCF STATUS, RP0
002B  1687  	BSF LCD_Read_00000_1_rw,5

		// first high nibble
		LCD_SetupDelay();
002C  0000  	NOP
002D  0000  	NOP

		e = 1;
002E  1707  	BSF LCD_Read_00000_1_e,6

		LCD_EnablePulseDelay();
002F  0000  	NOP
0030  0000  	NOP
0031  0000  	NOP
0032  0000  	NOP
0033  0000  	NOP

		d = data << 4;
0034  0E07  	SWAPF LCD_Read_00000_1_data, W
0035  39F0  	ANDLW 0xF0
0036  00C9  	MOVWF LCD_Read_00000_1_d

		e = 0;
0037  1307  	BCF LCD_Read_00000_1_e,6

		LCD_HoldupDelay();
0038  0000  	NOP

		LCD_CycleMakeupDelay();
0039  0000  	NOP
003A  0000  	NOP

			
		// then low nibble
		LCD_SetupDelay();
003B  0000  	NOP
003C  0000  	NOP

		e = 1;
003D  1707  	BSF LCD_Read_00000_1_e,6

		LCD_EnablePulseDelay();	
003E  0000  	NOP
003F  0000  	NOP
0040  0000  	NOP
0041  0000  	NOP
0042  0000  	NOP

		d |= data & 0x0F;
0043  300F  	MOVLW 0x0F
0044  0507  	ANDWF LCD_Read_00000_1_data, W
0045  04C9  	IORWF LCD_Read_00000_1_d, F

		e = 0;
0046  1307  	BCF LCD_Read_00000_1_e,6

		LCD_HoldupDelay();
0047  0000  	NOP

		LCD_CycleMakeupDelay();
0048  0000  	NOP
0049  0000  	NOP

	}


	if( InterfaceType == LCD_8_BIT_MODE )
	{
		// port input	
		tris = 0xFF;
		rw = 1; // set reading mode
		LCD_SetupDelay();
		e = 1;
		LCD_EnablePulseDelay();
		d = data;
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}
	
	return d;
004A  0849  	MOVF LCD_Read_00000_1_d, W
004B  00CA  	MOVWF CompTempVarRet620

}
004C  0008  	RETURN


_LCD_TEMPL
void LCD_RawWriteNibble( char d )

{
	// Note: this function is duplicate below, but declared inline.
	// this is to reduce stack depth usage
	// Note: this function is above, but declared inline.
	// this is to reduce stack depth usage
	volatile unsigned char data@DataPort, tris@Data_PortTris;
	volatile bit rw@CtrlPort.RW, e@CtrlPort.E;
	
	if( InterfaceType == LCD_4_BIT_HI_NIB_MODE )

	{
		// port upper nibble output
		rw = 0; // set writing mode
		LCD_SetupDelay();
		tris &= 0x0F;
		data &= 0x0F;
		data |= d & 0xF0;
		e = 1;
		LCD_EnablePulseDelay();
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}

	if( InterfaceType == LCD_4_BIT_LO_NIB_MODE )
	{
		// port upper nibble output
		rw = 0; // set writing mode
0092  1287  	BCF LCD_RawWri_00013_1_rw,5

		LCD_SetupDelay();
0093  0000  	NOP
0094  0000  	NOP

		tris &= 0xF0;
0095  30F0  	MOVLW 0xF0
0096  1683  	BSF STATUS, RP0
0097  0587  	ANDWF LCD_RawWri_00013_1_tris, F

		data &= 0xF0;
0098  30F0  	MOVLW 0xF0
0099  1283  	BCF STATUS, RP0
009A  0587  	ANDWF LCD_RawWri_00013_1_data, F

		data |= d >> 4;
009B  0E2E  	SWAPF LCD_RawWri_00013_arg_d, W
009C  390F  	ANDLW 0x0F
009D  0487  	IORWF LCD_RawWri_00013_1_data, F

		e = 1;
009E  1707  	BSF LCD_RawWri_00013_1_e,6

		LCD_EnablePulseDelay();
009F  0000  	NOP
00A0  0000  	NOP
00A1  0000  	NOP
00A2  0000  	NOP
00A3  0000  	NOP

		e = 0;
00A4  1307  	BCF LCD_RawWri_00013_1_e,6

		LCD_HoldupDelay();
00A5  0000  	NOP

		LCD_CycleMakeupDelay();
00A6  0000  	NOP
00A7  0000  	NOP

	}	
}
00A8  0008  	RETURN


_LCD_TEMPL
inline void LCD_RawWriteNibbleInline( char d )
{
	// Note: this function is above, but declared inline.
	// this is to reduce stack depth usage
	volatile unsigned char data@DataPort, tris@Data_PortTris;
	volatile bit rw@CtrlPort.RW, e@CtrlPort.E;
	
	if( InterfaceType == LCD_4_BIT_HI_NIB_MODE )
	{
		// port upper nibble output
		rw = 0; // set writing mode
		LCD_SetupDelay();
		tris &= 0x0F;
		data &= 0x0F;
		data |= d & 0xF0;
		e = 1;
		LCD_EnablePulseDelay();
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}

	if( InterfaceType == LCD_4_BIT_LO_NIB_MODE )
	{
		// port upper nibble output
		rw = 0; // set writing mode
		LCD_SetupDelay();
		tris &= 0xF0;
		data &= 0xF0;
		data |= d >> 4;
		e = 1;
		LCD_EnablePulseDelay();
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}	
}


_LCD_TEMPL
void LCD_RawWrite( char d )

{		
	volatile unsigned char tris@Data_PortTris, data@DataPort;
	volatile bit rw@CtrlPort.RW, e@CtrlPort.E;
		
	if( InterfaceType == LCD_4_BIT_HI_NIB_MODE  )

	{
		// output upper nibble, then lower nibble
		bit flag = 0;
		do
		{			
			_LCD_RawWriteNibbleInline( d );
			flag = !flag;
			d <<= 4;
		}
		while( flag );
	}	

	if( InterfaceType == LCD_4_BIT_LO_NIB_MODE )
	{
		// output upper nibble, then lower nibble
		bit flag = 0;
004D  1049  	BCF LCD_RawWri_00014_2_flag,0

		do
004E        label4

		{			
			_LCD_RawWriteNibbleInline( d );
004E  0848  	MOVF LCD_RawWri_00014_arg_d, W
004F  00CA  	MOVWF LCD_RawWri_00014_5_d
0050  1287  	BCF LCD_RawWri_00014_7_rw,5
0051  0000  	NOP
0052  0000  	NOP
0053  30F0  	MOVLW 0xF0
0054  1683  	BSF STATUS, RP0
0055  0587  	ANDWF LCD_RawWri_00014_7_tris, F
0056  30F0  	MOVLW 0xF0
0057  1283  	BCF STATUS, RP0
0058  0587  	ANDWF LCD_RawWri_00014_7_data, F
0059  0E4A  	SWAPF LCD_RawWri_00014_5_d, W
005A  390F  	ANDLW 0x0F
005B  0487  	IORWF LCD_RawWri_00014_7_data, F
005C  1707  	BSF LCD_RawWri_00014_7_e,6
005D  0000  	NOP
005E  0000  	NOP
005F  0000  	NOP
0060  0000  	NOP
0061  0000  	NOP
0062  1307  	BCF LCD_RawWri_00014_7_e,6
0063  0000  	NOP
0064  0000  	NOP
0065  0000  	NOP

			flag = !flag;
0066  01CA  	CLRF CompTempVar621
0067  1C49  	BTFSS LCD_RawWri_00014_2_flag,0
0068  0ACA  	INCF CompTempVar621, F
0069  1049  	BCF LCD_RawWri_00014_2_flag,0
006A  184A  	BTFSC CompTempVar621,0
006B  1449  	BSF LCD_RawWri_00014_2_flag,0

			d <<= 4;
006C  0EC8  	SWAPF LCD_RawWri_00014_arg_d, F
006D  30F0  	MOVLW 0xF0
006E  05C8  	ANDWF LCD_RawWri_00014_arg_d, F

		}
		while( flag );
006F  1849  	BTFSC LCD_RawWri_00014_2_flag,0
0070  284E  	GOTO	label4

	}	


	if( InterfaceType == LCD_8_BIT_MODE )
	{
		// port b output
		rw = 0; // set writing mode
		tris = 0x00;		
		data = d;
		LCD_SetupDelay();
		e = 1;
		LCD_EnablePulseDelay();
		e = 0;
		LCD_HoldupDelay();
		LCD_CycleMakeupDelay();
	}
}
0071  0008  	RETURN


_LCD_TEMPL
inline void LCD_WaitForNotBusy()
{
	volatile bit rs@CtrlPort.RS; bit old_RS = rs;	
	rs = 0;
	while( _LCD_Read() & 0x80 ); // wait while busy set
	rs = old_RS;
}

_LCD_TEMPL
void LCD_Write(char d )

{
	volatile bit rs@CtrlPort.RS;
	
	if( UseBusy == 1 )

	{	
		// wait until display Not busy before sending next data
		if ( writeDelayType == WriteControlled )
0072  08A3  	MOVF gbl_writeDelayType, F
0073  1D03  	BTFSS STATUS,Z
0074  2881  	GOTO	label7

			_LCD_WaitForNotBusy();
0075  1048  	BCF LCD_Write_00000_5_old_RS,0
0076  1E07  	BTFSS LCD_Write_00000_5_rs,4
0077  2879  	GOTO	label5
0078  1448  	BSF LCD_Write_00000_5_old_RS,0
0079        label5
0079  1207  	BCF LCD_Write_00000_5_rs,4
007A        label6
007A  2026  	CALL LCD_Read_00000
007B  1BCA  	BTFSC CompTempVarRet620,7
007C  287A  	GOTO	label6
007D  1848  	BTFSC LCD_Write_00000_5_old_RS,0
007E  1607  	BSF LCD_Write_00000_5_rs,4
007F  1C48  	BTFSS LCD_Write_00000_5_old_RS,0
0080  1207  	BCF LCD_Write_00000_5_rs,4
0081        label7

		
		_LCD_RawWrite( d );
0081  0847  	MOVF LCD_Write_00000_arg_d, W
0082  00C8  	MOVWF LCD_RawWri_00014_arg_d
0083  204D  	CALL LCD_RawWri_00014

	}
	else
	{		
 		_LCD_RawWrite( d );
		
		// give time to complete
		if ( writeDelayType == WriteControlled )
		{
			if( !rs && (d == return_home || d == clear_lcd) )
				delay_ms( 2 ); // return_home takes more time than other instructions to execute
			else
				delay_10us( 5 ); // 50us - enough time for normal command execution - clear and home need longer!!			
		}
	}
}
0084  0008  	RETURN


_LCD_TEMPL
void LCD_Clear()

{
	_LCD_FunctionMode();
00DD  1283  	BCF STATUS, RP0
00DE  1303  	BCF STATUS, RP1
00DF  1207  	BCF LCD_Clear_00000_4_rs,4

	_LCD_Write( clear_lcd ); // clear display
00E0  3001  	MOVLW 0x01
00E1  00C7  	MOVWF LCD_Write_00000_arg_d
00E2  2072  	CALL LCD_Write_00000

	_LCD_Write( return_home );
00E3  3002  	MOVLW 0x02
00E4  00C7  	MOVWF LCD_Write_00000_arg_d
00E5  2072  	CALL LCD_Write_00000

}
00E6  0008  	RETURN


_LCD_TEMPL
void LCD_Setup( void )

{
	// set control port bits used to output
	volatile bit trisRS@Ctrl_PortTris.RS, trisRW@Ctrl_PortTris.RW, trisE@Ctrl_PortTris.E;
	trisRS = 0;
06AD  1683  	BSF STATUS, RP0
06AE  1303  	BCF STATUS, RP1
06AF  1207  	BCF LCD_Setup_00000_1_trisRS,4

	trisRW = 0;
06B0  1287  	BCF LCD_Setup_00000_1_trisRW,5

	trisE = 0;
06B1  1307  	BCF LCD_Setup_00000_1_trisE,6

	
	writeDelayType = WriteNoDelay; // no delays in data writes
06B2  3001  	MOVLW 0x01
06B3  1283  	BCF STATUS, RP0
06B4  00A3  	MOVWF gbl_writeDelayType

	
	delay_ms(16); // Power up delay
06B5  3010  	MOVLW 0x10
06B6  00AE  	MOVWF delay_ms_00000_arg_del
06B7  2010  	CALL delay_ms_00000

	_LCD_FunctionMode();
06B8  1207  	BCF LCD_Setup_00000_11_rs,4


	if( InterfaceType == LCD_4_BIT_HI_NIB_MODE )
	{
		// Reset sequence as described in data sheets
		_LCD_RawWriteNibble( system_set_reset ); 
		delay_ms(5); // min delay here of 4.1 ms
		_LCD_RawWriteNibble( system_set_reset );
		delay_10us(100); // min delay here of 100us
		_LCD_RawWriteNibble( system_set_reset );
	   
		// LCD busy flag is valid from this point onwards
		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
		else
			delay_10us( 5 ); // standard command delay time
		
		_LCD_RawWriteNibble( system_set_4_bit );
		
		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
		else
			delay_10us( 5 ); // standard command delay time

		writeDelayType = WriteControlled;
		_LCD_Write( system_set_4_bit );
	}

	if( InterfaceType == LCD_4_BIT_LO_NIB_MODE )
	{
		// Reset sequence as described in data sheets
		_LCD_RawWriteNibble( system_set_reset ); 
06B9  3030  	MOVLW 0x30
06BA  00AE  	MOVWF LCD_RawWri_00013_arg_d
06BB  2092  	CALL LCD_RawWri_00013

		delay_ms(5); // min delay here of 4.1 ms
06BC  3005  	MOVLW 0x05
06BD  00AE  	MOVWF delay_ms_00000_arg_del
06BE  2010  	CALL delay_ms_00000

		_LCD_RawWriteNibble( system_set_reset );
06BF  3030  	MOVLW 0x30
06C0  00AE  	MOVWF LCD_RawWri_00013_arg_d
06C1  2092  	CALL LCD_RawWri_00013

		delay_10us(100); // min delay here of 100us
06C2  3064  	MOVLW 0x64
06C3  00AE  	MOVWF delay_10us_00000_arg_del
06C4  201C  	CALL delay_10us_00000

		_LCD_RawWriteNibble( system_set_reset );
06C5  3030  	MOVLW 0x30
06C6  00AE  	MOVWF LCD_RawWri_00013_arg_d
06C7  2092  	CALL LCD_RawWri_00013

	   
		// LCD busy flag is valid from this point onwards
		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
06C8  102E  	BCF LCD_Setup_00000_30_old_RS,0
06C9  1A07  	BTFSC LCD_Setup_00000_30_rs,4
06CA  142E  	BSF LCD_Setup_00000_30_old_RS,0
06CB  1207  	BCF LCD_Setup_00000_30_rs,4
06CC        label80
06CC  2026  	CALL LCD_Read_00000
06CD  1BCA  	BTFSC CompTempVarRet620,7
06CE  2ECC  	GOTO	label80
06CF  182E  	BTFSC LCD_Setup_00000_30_old_RS,0
06D0  1607  	BSF LCD_Setup_00000_30_rs,4
06D1  1C2E  	BTFSS LCD_Setup_00000_30_old_RS,0
06D2  1207  	BCF LCD_Setup_00000_30_rs,4

		else
			delay_10us( 5 ); // standard command delay time
		
		_LCD_RawWriteNibble( system_set_4_bit );
06D3  3028  	MOVLW 0x28
06D4  00AE  	MOVWF LCD_RawWri_00013_arg_d
06D5  2092  	CALL LCD_RawWri_00013

		
		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
06D6  102E  	BCF LCD_Setup_00000_39_old_RS,0
06D7  1A07  	BTFSC LCD_Setup_00000_39_rs,4
06D8  142E  	BSF LCD_Setup_00000_39_old_RS,0
06D9  1207  	BCF LCD_Setup_00000_39_rs,4
06DA        label81
06DA  2026  	CALL LCD_Read_00000
06DB  1BCA  	BTFSC CompTempVarRet620,7
06DC  2EDA  	GOTO	label81
06DD  182E  	BTFSC LCD_Setup_00000_39_old_RS,0
06DE  1607  	BSF LCD_Setup_00000_39_rs,4
06DF  1C2E  	BTFSS LCD_Setup_00000_39_old_RS,0
06E0  1207  	BCF LCD_Setup_00000_39_rs,4

		else
			delay_10us( 5 ); // standard command delay time

		writeDelayType = WriteControlled;
06E1  01A3  	CLRF gbl_writeDelayType

		_LCD_Write( system_set_4_bit );
06E2  3028  	MOVLW 0x28
06E3  00C7  	MOVWF LCD_Write_00000_arg_d
06E4  2072  	CALL LCD_Write_00000

	}
	
	if( InterfaceType == LCD_8_BIT_MODE )
	{
		// Reset sequence as described in data sheets
		_LCD_RawWrite( system_set_reset ); 
		delay_ms(5); // min delay here of 4.1 ms
		_LCD_RawWrite( system_set_reset );
		delay_10us(10); // min delay here of 100us
		_LCD_RawWrite( system_set_reset );
	   
		// busy flag is valid from this point onwards
		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
		else
			delay_10us( 5 ); // standard command delay time

		_LCD_RawWrite( system_set_8_bit );	

		if( UseBusy == 1 )
			_LCD_WaitForNotBusy();
		else
			delay_10us( 5 ); // standard command delay time
		
		writeDelayType = WriteControlled; // use busy
	}
		
	_LCD_Write( entry_mode );
06E5  3006  	MOVLW 0x06
06E6  00C7  	MOVWF LCD_Write_00000_arg_d
06E7  2072  	CALL LCD_Write_00000

	_LCD_Write( display_on );
06E8  300C  	MOVLW 0x0C
06E9  00C7  	MOVWF LCD_Write_00000_arg_d
06EA  2072  	CALL LCD_Write_00000

	_LCD_Write( set_dd_ram );
06EB  3080  	MOVLW 0x80
06EC  00C7  	MOVWF LCD_Write_00000_arg_d
06ED  2072  	CALL LCD_Write_00000

}
06EE  0008  	RETURN


_LCD_TEMPL
void LCD_Printf( const char *lcdptr )

{
	char pi = 0, c;
00A9  01C5  	CLRF LCD_Printf_00000_1_pi

	_LCD_DataMode();
00AA  1607  	BSF LCD_Printf_00000_4_rs,4

    while( 1 )
00AB        label10
00CC  28AB  	GOTO	label10

    {
		c = lcdptr[pi++];
00AB  1383  	BCF STATUS,IRP
00AC  182F  	BTFSC LCD_Printf_00000_arg_lcdptr+D'1',0
00AD  1783  	BSF STATUS,IRP
00AE  082E  	MOVF LCD_Printf_00000_arg_lcdptr, W
00AF  0084  	MOVWF FSR
00B0  1383  	BCF STATUS,IRP
00B1  182F  	BTFSC LCD_Printf_00000_arg_lcdptr+D'1',0
00B2  1783  	BSF STATUS,IRP
00B3  082E  	MOVF LCD_Printf_00000_arg_lcdptr, W
00B4  0084  	MOVWF FSR
00B5  0845  	MOVF LCD_Printf_00000_1_pi, W
00B6  00C7  	MOVWF CompTempVar596
00B7  0AC5  	INCF LCD_Printf_00000_1_pi, F
00B8  0847  	MOVF CompTempVar596, W
00B9  0784  	ADDWF FSR, F
00BA  0800  	MOVF INDF, W
00BB  00C6  	MOVWF LCD_Printf_00000_1_c

		if ( !c )
00BC  08C6  	MOVF LCD_Printf_00000_1_c, F
00BD  1903  	BTFSC STATUS,Z

			return;
		if ( c == '\n' )
00BF  0846  	MOVF LCD_Printf_00000_1_c, W
00C0  3A0A  	XORLW 0x0A
00C1  1D03  	BTFSS STATUS,Z
00C2  28C9  	GOTO	label11
00C9        label11

		{
			_LCD_FunctionMode();
00C3  1207  	BCF LCD_Printf_00000_10_rs,4

			// move to start second line
			_LCD_Write( set_dd_ram + 0x40 );
00C4  30C0  	MOVLW 0xC0
00C5  00C7  	MOVWF LCD_Write_00000_arg_d
00C6  2072  	CALL LCD_Write_00000

			_LCD_DataMode();
00C7  1607  	BSF LCD_Printf_00000_16_rs,4

		}
		else
00C8  28AB  	GOTO	label10

			_LCD_Write( c );// Display on LCD
00C9  0846  	MOVF LCD_Printf_00000_1_c, W
00CA  00C7  	MOVWF LCD_Write_00000_arg_d
00CB  2072  	CALL LCD_Write_00000

	}
}
00BE  0008  	RETURN


_LCD_TEMPL
void LCD_Printf( rom char *lcdptr )
{
	char pi = 0, c;
	_LCD_DataMode();
    while( 1 )
    {
		c = lcdptr[pi++];
		if ( !c )
			return;
		if ( c == '\n' )
		{
			_LCD_FunctionMode();
			// move to start second line
			_LCD_Write( set_dd_ram + 0x40 ); 
			_LCD_DataMode();
		}
		else
			_LCD_Write( c );// Display on LCD
	}
}

_LCD_TEMPL
void LCD_Printf( const char *lcdptr, unsigned int val ) // JS - Accept unsigned by default
{
	unsigned char pi = 0, bi, c, fill, baseOrBits, sign, mask;
	unsigned char buff[ 10 ]; // max length allow is 9
	bit pad;
	
	_LCD_DataMode();
    while( 1 )
    {
		c = lcdptr[pi++]; if ( !c ) return;
		
		switch( c )
		{
		case '\n':
			_LCD_FunctionMode();
			// move to start second line
			_LCD_Write( set_dd_ram + 0x40 );
			_LCD_DataMode();
			break;
		case '%':
			c = lcdptr[pi++]; if ( !c ) return;
			
			//Handle escape sequence that prints '%'
			if ( c == '%' )
			{
				_LCD_Write( c );// Display on LCD
				break;
			}
			
			// Next character if zero indicates that we should zero fill output
			if ( c == '0' )
			{
				fill = '0';
				c = lcdptr[pi++]; if ( !c ) return;
			}
			else
				fill = ' ';

			// Next character if valid digit indicates field width
			if( c > '0' && c <= '9' )
			{
				pad = 1;
				bi = c - 48;;				
				c = lcdptr[pi++]; if ( !c ) return;
			}
			else
			{
				pad = 0;
				bi = sizeof( buff ) - 1;
			}
				
			
			// Next character indicates the radix (number base)
			sign = 0;
			switch( c )
			{
			case 'd':
				if( val & 0x8000 )	// Negative values must be adjusted to be positive // JS
				{
					sign = '-';
					val ^= 0xFFFF; // 2s complement negate	// JS
					val++;
				}
			case 'u':
				baseOrBits = 10; // base ten, divide by ten per digit
				break;			
			case 'X':
				baseOrBits = 4; // base 16, requires a 4 bit shift per digit
				mask = 0x0F;
				break;
			case 'b':
				baseOrBits = 1; // base 16, requires a 1 bit shift per digit
				mask = 0x01;
				break;
			default:
				return; // no radix
			}
				
			// null terminate, then reverse fill string
			buff[ bi ] = '\0';
			
			bit first = true;				
			while( bi )
			{
				bi--;
				if( val || first )
				{
					first = false;
										
					if( baseOrBits == 10 )
					{
						c = (unsigned char)(val % 10);	// JS - Optimization, use absolute of 10
						val /= 10;	// JS - Optimization, use absolute of 10
					}
					else
					{
						c = val & mask;
						val = ((unsigned int)val) >> baseOrBits;						
					}
					
					if( c > 9 )
						c += 55; // convert to hex digits character A-F
					else
						c += 48; // convert to digit character 0-9

				}
				else
				{
					if( sign && (bi == 0 || fill != '0') )
					{
						c = sign;
						sign = 0;
					}
					else
						c = fill;
				}
				
				buff[ bi ] = c;
				
				if( pad == 0 && val == 0 && sign == 0 )
					break;
			}
			// output string to display
			while( 1 )
			{
				c = buff[ bi ];
				if( !c ) break;
				_LCD_Write( c );// Display on LCD
				bi++;
			}
			break;
		default:
			_LCD_Write( c );// Display on LCD
			break;
		}
	}
}

_LCD_TEMPL
void LCD_GotoXy( char x, char y )

{
	// displays memory mapping with two lines:
	// line 1: 0x00
	// line 2: 0x40
	
	// display memory mapping with four lines:
	// line 1: 0x00
	// line 2: 0x40
	// line 3: 0x14
	// line 4: 0x54
	
	_LCD_FunctionMode();
00CD  1207  	BCF LCD_GotoXy_00000_4_rs,4

	unsigned char offset = x;
00CE  082E  	MOVF LCD_GotoXy_00000_arg_x, W
00CF  00B0  	MOVWF LCD_GotoXy_00000_1_offset

	if( y & 0x01 ) offset += 0x40;
00D0  1C2F  	BTFSS LCD_GotoXy_00000_arg_y,0
00D1  28D4  	GOTO	label12
00D2  3040  	MOVLW 0x40
00D3  07B0  	ADDWF LCD_GotoXy_00000_1_offset, F
00D4        label12

	if( y & 0x02 ) offset += 0x14;		
00D4  1CAF  	BTFSS LCD_GotoXy_00000_arg_y,1
00D5  28D8  	GOTO	label13
00D6  3014  	MOVLW 0x14
00D7  07B0  	ADDWF LCD_GotoXy_00000_1_offset, F
00D8        label13

	_LCD_Write( set_dd_ram + offset );
00D8  0830  	MOVF LCD_GotoXy_00000_1_offset, W
00D9  3E80  	ADDLW 0x80
00DA  00C7  	MOVWF LCD_Write_00000_arg_d
00DB  2072  	CALL LCD_Write_00000

}
00DC  0008  	RETURN



_LCD_TEMPL
void LCD_Function( char func )
{
	_LCD_FunctionMode();
	_LCD_Write( func );
}

////////////////////////////////////////////////////////////////////////////
// Helpers that hide template arguments
////////////////////////////////////////////////////////////////////////////
// low level functions
#define lcd_write		LCD_Write<LCD_ARGS>
#define lcd_waitfornotbusy LCD_WaitForNotBusy<LCD_ARGS>
#define lcd_read		LCD_Read<LCD_ARGS>
#define lcd_funcmode	LCD_FunctionMode<LCD_ARGS>
#define lcd_datamode	LCD_DataMode<LCD_ARGS>


// high level functions - these all set function or data mode as required
#define lcd_setup		LCD_Setup<LCD_ARGS>
#define lprintf			LCD_Printf<LCD_ARGS>
#define lcd_clear		LCD_Clear<LCD_ARGS>
#define lcd_gotoxy		LCD_GotoXy<LCD_ARGS>
#define lcd_function 	LCD_Function<LCD_ARGS>

#include <system.h>		//Inclui as definições principais do programa
#include<lcd_driver.h>

#define LCD_ARGS	 1,	/* Interface type: mode 0 = 8bit, 1 = 4bit(low nibble), 2 = 4bit(upper nibble) */ \
		1,				/* Use busy signal: 1 = use busy, 0 = use time delays */\
		PORTC, TRISC, 	/* Data port and data port tris register */ \
		PORTC, TRISC, 	/* Control port and control port tris register */ \
		4,				/* Bit number of control port is connected to RS */ \
		5,				/* Bit number of control port is connected to RW */ \
		6 				/* Bit number of control port is connected to Enable */ \
		
	void teste();
		void controle();
	void status();
		void comando();
	void escreve();
		void cor();
	void efeito();

char contador, delay, segundo, estado, controle, stop, pause, cor, efeito, lamp;
// Declara variáveis do tipo char

void interrupt()	//Rotina que comanda as interrupções de tempo

{
	if(test_bit(intcon,T0IF))
0714  1D0B  	BTFSS gbl_intcon,2
0715  2F2A  	GOTO	label85
072A        label85

		{
			tmr0 = 131;
0716  3083  	MOVLW 0x83
0717  1283  	BCF STATUS, RP0
0718  1303  	BCF STATUS, RP1
0719  0081  	MOVWF gbl_tmr0

			contador++;		// Incrementa var contador
071A  0AA4  	INCF gbl_contador, F

			delay++;
071B  0AA5  	INCF gbl_delay, F

			
			if(delay == 125)
071C  0825  	MOVF gbl_delay, W
071D  3A7D  	XORLW 0x7D
071E  1903  	BTFSC STATUS,Z

			delay = 0;
071F  01A5  	CLRF gbl_delay

			if(contador == 125) //Cada 125 ciclos corresponde a exato 1 segundo
0720  0824  	MOVF gbl_contador, W
0721  3A7D  	XORLW 0x7D
0722  1D03  	BTFSS STATUS,Z
0723  2F29  	GOTO	label84

				{
					segundo++;	//Incrementa segundo
0724  0AA6  	INCF gbl_segundo, F

					if(segundo == 5)
0725  0826  	MOVF gbl_segundo, W
0726  3A05  	XORLW 0x05
0727  1903  	BTFSC STATUS,Z

							
							segundo = 0;	// a cada 4 segundos a contagem é reiniciada
0728  01A6  	CLRF gbl_segundo
0729        label84

				}	
			clear_bit(intcon,T0IF);
0729  110B  	BCF gbl_intcon,2

		}
}
072A  1283  	BCF STATUS, RP0
072B  1303  	BCF STATUS, RP1
072C  0E22  	SWAPF Int1BContext+D'2', W
072D  0084  	MOVWF FSR
072E  0E21  	SWAPF Int1BContext+D'1', W
072F  008A  	MOVWF PCLATH
0730  0E20  	SWAPF Int1BContext, W
0731  0083  	MOVWF STATUS
0732  0EFF  	SWAPF Int1Context, F
0733  0E7F  	SWAPF Int1Context, W
0734  0009  	RETFIE


void main()	//Rotina que contém os comandos principais para iniciar o programa

{
	trisa = 0;		
06EF  1683  	BSF STATUS, RP0
06F0  1303  	BCF STATUS, RP1
06F1  0185  	CLRF gbl_trisa

	trisb = 7;
06F2  3007  	MOVLW 0x07
06F3  0086  	MOVWF gbl_trisb

	porta = 0;
06F4  1283  	BCF STATUS, RP0
06F5  0185  	CLRF gbl_porta

	portb = 0;
06F6  0186  	CLRF gbl_portb

		
		estado = 0;
06F7  01A7  	CLRF gbl_estado

		segundo = 0;			// Inicia todas as varíaveis com valor zero
06F8  01A6  	CLRF gbl_segundo

		controle = 0;
06F9  01A8  	CLRF gbl_controle

		stop = 0;
06FA  01A9  	CLRF gbl_stop

		pause = 0;
06FB  01AA  	CLRF gbl_pause

		cor = 0;
06FC  01AB  	CLRF gbl_cor

		efeito = 0;
06FD  01AC  	CLRF gbl_efeito

		lamp = 0;
06FE  01AD  	CLRF gbl_lamp

	
		
			lcd_setup();
06FF  26AD  	CALL LCD_Setup_00000

				lcd_clear();
0700  20DD  	CALL LCD_Clear_00000

	
	option_reg = 133;
0701  3085  	MOVLW 0x85
0702  1683  	BSF STATUS, RP0
0703  0081  	MOVWF gbl_option_reg

	tmr0=131;
0704  3083  	MOVLW 0x83
0705  1283  	BCF STATUS, RP0
0706  0081  	MOVWF gbl_tmr0

	set_bit(intcon,T0IE);	 // As interrupções de tempo são ativadas
0707  168B  	BSF gbl_intcon,5

	set_bit(intcon,GIE);
0708  178B  	BSF gbl_intcon,7


do	// Enquanto o circuito estiver ligado, while(1), serão executadas as sub-rotinas abaixo
0709        label82

		{
			teste();
0709  20E7  	CALL teste_00000

			status();
070A  2123  	CALL status_00000

			comando();
070B  2647  	CALL comando_00000

			controle();
070C  260A  	CALL controle_00000

			escreve();
070D  2136  	CALL escreve_00000

			cor();
070E  251E  	CALL cor_00000

			efeito();
070F  2342  	CALL efeito_00000

		}while(1);
0710  2F09  	GOTO	label82

}	//Fim do void main


void teste()	// Liga e desliga o circuito de acordo com os testes e modifica variáveis

{

		if((test_bit(portb,0) == 0) && (stop == 0))
00E7  3001  	MOVLW 0x01
00E8  1283  	BCF STATUS, RP0
00E9  1303  	BCF STATUS, RP1
00EA  0506  	ANDWF gbl_portb, W
00EB  00AE  	MOVWF CompTempVar545
00EC  08AE  	MOVF CompTempVar545, F
00ED  1D03  	BTFSS STATUS,Z
00EE  28F8  	GOTO	label14
00EF  08A9  	MOVF gbl_stop, F
00F0  1D03  	BTFSS STATUS,Z
00F1  28F8  	GOTO	label14
00F8        label14

			{	
			delay_ms(20);
00F2  3014  	MOVLW 0x14
00F3  00AE  	MOVWF delay_ms_00000_arg_del
00F4  2010  	CALL delay_ms_00000

			estado = 1;		// Se verdadeiro, liga o circuito tirando-o do modo "Stand-By"
00F5  3001  	MOVLW 0x01
00F6  00A7  	MOVWF gbl_estado

			stop = 1;
00F7  00A9  	MOVWF gbl_stop

			}

		if((test_bit(portb,0) == 1) && (stop == 1))
00F8  3001  	MOVLW 0x01
00F9  0506  	ANDWF gbl_portb, W
00FA  00AE  	MOVWF CompTempVar546
00FB  032E  	DECF CompTempVar546, W
00FC  1D03  	BTFSS STATUS,Z
00FD  2903  	GOTO	label15
00FE  0329  	DECF gbl_stop, W
00FF  1D03  	BTFSS STATUS,Z
0100  2903  	GOTO	label15
0103        label15

			stop = 2;
0101  3002  	MOVLW 0x02
0102  00A9  	MOVWF gbl_stop

		
		if((test_bit(portb,0) == 0) && (stop == 2))
0103  3001  	MOVLW 0x01
0104  0506  	ANDWF gbl_portb, W
0105  00AE  	MOVWF CompTempVar547
0106  08AE  	MOVF CompTempVar547, F
0107  1D03  	BTFSS STATUS,Z
0108  2918  	GOTO	label16
0109  0829  	MOVF gbl_stop, W
010A  3A02  	XORLW 0x02
010B  1D03  	BTFSS STATUS,Z
010C  2918  	GOTO	label16
0118        label16

			{
			delay_ms(20);		// coloca o circuito em "Stand-By" e zera todas as variáveis
010D  3014  	MOVLW 0x14
010E  00AE  	MOVWF delay_ms_00000_arg_del
010F  2010  	CALL delay_ms_00000

			controle = 0;
0110  01A8  	CLRF gbl_controle

			  estado = 0;
0111  01A7  	CLRF gbl_estado

			  efeito = 0;
0112  01AC  	CLRF gbl_efeito

			   portb = 0;
0113  0186  	CLRF gbl_portb

			    lamp = 0;
0114  01AD  	CLRF gbl_lamp

			     cor = 0;
0115  01AB  	CLRF gbl_cor

			    stop = 4;
0116  3004  	MOVLW 0x04
0117  00A9  	MOVWF gbl_stop

			 }
		if((test_bit(portb,0) == 1) && (stop == 4))
0118  3001  	MOVLW 0x01
0119  0506  	ANDWF gbl_portb, W
011A  00AE  	MOVWF CompTempVar548
011B  032E  	DECF CompTempVar548, W
011C  1D03  	BTFSS STATUS,Z
011E  0829  	MOVF gbl_stop, W
011F  3A04  	XORLW 0x04
0120  1903  	BTFSC STATUS,Z

			stop = 0;
0121  01A9  	CLRF gbl_stop


}	//Fim do void teste
011D  0008  	RETURN
0122  0008  	RETURN


void controle()	// Seleciona, através de uma tecla, a ação do circuito do 555 no PIC

{
		if((test_bit(portb,1) == 0) && (pause == 0))
060A  3002  	MOVLW 0x02
060B  1283  	BCF STATUS, RP0
060C  1303  	BCF STATUS, RP1
060D  0506  	ANDWF gbl_portb, W
060E  00AE  	MOVWF CompTempVar549
060F  08AE  	MOVF CompTempVar549, F
0610  1D03  	BTFSS STATUS,Z
0611  2E1B  	GOTO	label66
0612  08AA  	MOVF gbl_pause, F
0613  1D03  	BTFSS STATUS,Z
0614  2E1B  	GOTO	label66
061B        label66

			{
			delay_ms(20);
0615  3014  	MOVLW 0x14
0616  00AE  	MOVWF delay_ms_00000_arg_del
0617  2010  	CALL delay_ms_00000

			controle++;
0618  0AA8  	INCF gbl_controle, F

			pause = 1;
0619  3001  	MOVLW 0x01
061A  00AA  	MOVWF gbl_pause

			}
		
		if((test_bit(portb,1) == 2) && (pause == 1))
061B  3002  	MOVLW 0x02
061C  0506  	ANDWF gbl_portb, W
061D  00AE  	MOVWF CompTempVar550
061E  082E  	MOVF CompTempVar550, W
061F  3A02  	XORLW 0x02
0620  1D03  	BTFSS STATUS,Z
0621  2E27  	GOTO	label67
0622  032A  	DECF gbl_pause, W
0623  1D03  	BTFSS STATUS,Z
0624  2E27  	GOTO	label67
0627        label67

			pause = 2;
0625  3002  	MOVLW 0x02
0626  00AA  	MOVWF gbl_pause

			
		if((test_bit(portb,1) == 0) && (pause == 2))
0627  3002  	MOVLW 0x02
0628  0506  	ANDWF gbl_portb, W
0629  00AE  	MOVWF CompTempVar551
062A  08AE  	MOVF CompTempVar551, F
062B  1D03  	BTFSS STATUS,Z
062C  2E37  	GOTO	label68
062D  082A  	MOVF gbl_pause, W
062E  3A02  	XORLW 0x02
062F  1D03  	BTFSS STATUS,Z
0630  2E37  	GOTO	label68
0637        label68

			{
			delay_ms(20);
0631  3014  	MOVLW 0x14
0632  00AE  	MOVWF delay_ms_00000_arg_del
0633  2010  	CALL delay_ms_00000

			controle++;
0634  0AA8  	INCF gbl_controle, F

			pause = 4;
0635  3004  	MOVLW 0x04
0636  00AA  	MOVWF gbl_pause

			}
			
		if((test_bit(portb,1) == 2) && (pause == 4))
0637  3002  	MOVLW 0x02
0638  0506  	ANDWF gbl_portb, W
0639  00AE  	MOVWF CompTempVar552
063A  082E  	MOVF CompTempVar552, W
063B  3A02  	XORLW 0x02
063C  1D03  	BTFSS STATUS,Z
063D  2E42  	GOTO	label69
063E  082A  	MOVF gbl_pause, W
063F  3A04  	XORLW 0x04
0640  1903  	BTFSC STATUS,Z

			pause = 0;
0641  01AA  	CLRF gbl_pause
0642        label69

		
		if(controle == 4)
0642  0828  	MOVF gbl_controle, W
0643  3A04  	XORLW 0x04
0644  1903  	BTFSC STATUS,Z

			controle = 0;
0645  01A8  	CLRF gbl_controle

			
}	//Fim do void controle
0646  0008  	RETURN


void status()	// Indica em 3 LEDs a condição de funcionamento do circuito

{
	if(estado == 1)
0123  1283  	BCF STATUS, RP0
0124  1303  	BCF STATUS, RP1
0125  0327  	DECF gbl_estado, W
0126  1D03  	BTFSS STATUS,Z
0127  2933  	GOTO	label18
0133        label18

	{
		if(lamp == 0)
0128  08AD  	MOVF gbl_lamp, F
0129  1D03  	BTFSS STATUS,Z
012A  292D  	GOTO	label17
012D        label17

		
		porta = 34; 	// Liga LED verde, liga Back-light do display e habilita o 555
012B  3022  	MOVLW 0x22
012C  0085  	MOVWF gbl_porta

		
		if(lamp == 1)
012D  032D  	DECF gbl_lamp, W
012E  1D03  	BTFSS STATUS,Z

		
		porta = 44; 	// Aciona Relé da lâmpada no RB3, LED azul
0130  302C  	MOVLW 0x2C
0131  0085  	MOVWF gbl_porta

		
	}else
		porta = 9; // Liga LED RGB na cor vermelho indicando que o circuito está em "Stand-By",
0133  3009  	MOVLW 0x09
0134  0085  	MOVWF gbl_porta

						//e tambem a lâmpada
}	//Fim do void status
012F  0008  	RETURN
0132  0008  	RETURN
0135  0008  	RETURN


//Obs.: Stand By: Estado no qual quase todas as variáveis ficam zeradas e 555 inativo

void comando()	// Define as variáveis cor e efeito, de acordo com o valor do "controle"

{

	if((estado == 1) && (test_bit(portb,2) == 4))
0647  1283  	BCF STATUS, RP0
0648  1303  	BCF STATUS, RP1
0649  0327  	DECF gbl_estado, W
064A  1D03  	BTFSS STATUS,Z
064C  3004  	MOVLW 0x04
064D  0506  	ANDWF gbl_portb, W
064E  00AE  	MOVWF CompTempVar553
064F  082E  	MOVF CompTempVar553, W
0650  3A04  	XORLW 0x04
0651  1D03  	BTFSS STATUS,Z

		{
		if(controle == 1)
0653  0328  	DECF gbl_controle, W
0654  1D03  	BTFSS STATUS,Z
0655  2E68  	GOTO	label72
0656        label70
0668        label72

		{
					// Enquanto for verdadeiro, incrementa a var cor em +1
			while((estado == 1) && (test_bit(portb,2) == 4) && (controle == 1));
0656  0327  	DECF gbl_estado, W
0657  1D03  	BTFSS STATUS,Z
0658  2E64  	GOTO	label71
0659  3004  	MOVLW 0x04
065A  0506  	ANDWF gbl_portb, W
065B  00AE  	MOVWF CompTempVar556
065C  082E  	MOVF CompTempVar556, W
065D  3A04  	XORLW 0x04
065E  1D03  	BTFSS STATUS,Z
065F  2E64  	GOTO	label71
0660  0328  	DECF gbl_controle, W
0661  1D03  	BTFSS STATUS,Z
0662  2E64  	GOTO	label71
0663  2E56  	GOTO	label70
0664        label71

			{
			delay_ms(20);
0664  3014  	MOVLW 0x14
0665  00AE  	MOVWF delay_ms_00000_arg_del
0666  2010  	CALL delay_ms_00000

			cor++;
0667  0AAB  	INCF gbl_cor, F

			}
		}
	if(cor == 6)					// Quando a var cor for igual a 6
0668  082B  	MOVF gbl_cor, W
0669  3A06  	XORLW 0x06
066A  1D03  	BTFSS STATUS,Z
066B  2E70  	GOTO	label73
0670        label73

		{						   // esta é zerada
			delay_ms(20);		
066C  3014  	MOVLW 0x14
066D  00AE  	MOVWF delay_ms_00000_arg_del
066E  2010  	CALL delay_ms_00000

			cor = 0;
066F  01AB  	CLRF gbl_cor

		}
	
		if(controle == 2)
0670  0828  	MOVF gbl_controle, W
0671  3A02  	XORLW 0x02
0672  1D03  	BTFSS STATUS,Z
0673  2E86  	GOTO	label76
0674        label74
0686        label76

		{
			while((estado == 1) && (test_bit(portb,2) == 4) && (controle == 2));
0674  0327  	DECF gbl_estado, W
0675  1D03  	BTFSS STATUS,Z
0676  2E82  	GOTO	label75
0677  3004  	MOVLW 0x04
0678  0506  	ANDWF gbl_portb, W
0679  00AE  	MOVWF CompTempVar559
067A  082E  	MOVF CompTempVar559, W
067B  3A04  	XORLW 0x04
067C  1D03  	BTFSS STATUS,Z
067D  2E82  	GOTO	label75
067E  0828  	MOVF gbl_controle, W
067F  3A02  	XORLW 0x02
0680  1903  	BTFSC STATUS,Z
0681  2E74  	GOTO	label74
0682        label75

			{
			delay_ms(20);
0682  3014  	MOVLW 0x14
0683  00AE  	MOVWF delay_ms_00000_arg_del
0684  2010  	CALL delay_ms_00000

			efeito++;
0685  0AAC  	INCF gbl_efeito, F

			}
		}
	
	if(efeito == 5)
0686  082C  	MOVF gbl_efeito, W
0687  3A05  	XORLW 0x05
0688  1D03  	BTFSS STATUS,Z
0689  2E8E  	GOTO	label77
068E        label77

			{
			delay_ms(20);
068A  3014  	MOVLW 0x14
068B  00AE  	MOVWF delay_ms_00000_arg_del
068C  2010  	CALL delay_ms_00000

			efeito = 0;
068D  01AC  	CLRF gbl_efeito

			}
			
		if(controle == 3)
068E  0828  	MOVF gbl_controle, W
068F  3A03  	XORLW 0x03
0690  1D03  	BTFSS STATUS,Z

		{
			while((estado == 1) && (test_bit(portb,2) == 4) && (controle == 3));
0692  0327  	DECF gbl_estado, W
0693  1D03  	BTFSS STATUS,Z
0694  2EA0  	GOTO	label79
0695  3004  	MOVLW 0x04
0696  0506  	ANDWF gbl_portb, W
0697  00AE  	MOVWF CompTempVar562
0698  082E  	MOVF CompTempVar562, W
0699  3A04  	XORLW 0x04
069A  1D03  	BTFSS STATUS,Z
069B  2EA0  	GOTO	label79
069C  0828  	MOVF gbl_controle, W
069D  3A03  	XORLW 0x03
069E  1903  	BTFSC STATUS,Z
069F  2E92  	GOTO	label78
06A0        label79

			{
			delay_ms(20);
06A0  3014  	MOVLW 0x14
06A1  00AE  	MOVWF delay_ms_00000_arg_del
06A2  2010  	CALL delay_ms_00000

			lamp++;
06A3  0AAD  	INCF gbl_lamp, F

			}
			
		if(lamp == 2)
06A4  082D  	MOVF gbl_lamp, W
06A5  3A02  	XORLW 0x02
06A6  1D03  	BTFSS STATUS,Z

			{
			delay_ms(20);
06A8  3014  	MOVLW 0x14
06A9  00AE  	MOVWF delay_ms_00000_arg_del
06AA  2010  	CALL delay_ms_00000

			lamp = 0;
06AB  01AD  	CLRF gbl_lamp

			}
		}
	}	
}	//Fim do void comando
064B  0008  	RETURN
0652  0008  	RETURN
0691  0008  	RETURN
0692        label78
06A7  0008  	RETURN
06AC  0008  	RETURN


void cor()		// Contém os efeitos, instruções para cada LED ( RED, GREEN AND BLUE )

{

if((estado == 1) && (controle == 1))// Se verdadeiro executa o switch de acordo com o caso
051E  1283  	BCF STATUS, RP0
051F  1303  	BCF STATUS, RP1
0520  0327  	DECF gbl_estado, W
0521  1D03  	BTFSS STATUS,Z
0523  0328  	DECF gbl_controle, W
0524  1D03  	BTFSS STATUS,Z

	{
		
		switch ( cor ) // Variável alvo

			{
		
		case 0: // Quando a var cor for igual a zero, executa o bloco de ações do case 0
0526  082B  	MOVF gbl_cor, W
0527  3A00  	XORLW 0x00
0528  1903  	BTFSC STATUS,Z
0529  2D3A  	GOTO	label60
053A        label60

		{
		lcd_gotoxy(5,1);
053A  3005  	MOVLW 0x05
053B  00AE  	MOVWF LCD_GotoXy_00000_arg_x
053C  3001  	MOVLW 0x01
053D  00AF  	MOVWF LCD_GotoXy_00000_arg_y
053E  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Vermelho      ");
053F  3020  	MOVLW 0x20
0540  00B0  	MOVWF CompTempVar597
0541  00B9  	MOVWF CompTempVar597+D'9'
0542  00BA  	MOVWF CompTempVar597+D'10'
0543  00BB  	MOVWF CompTempVar597+D'11'
0544  00BC  	MOVWF CompTempVar597+D'12'
0545  00BD  	MOVWF CompTempVar597+D'13'
0546  00BE  	MOVWF CompTempVar597+D'14'
0547  3056  	MOVLW 0x56
0548  00B1  	MOVWF CompTempVar597+D'1'
0549  3065  	MOVLW 0x65
054A  00B2  	MOVWF CompTempVar597+D'2'
054B  00B5  	MOVWF CompTempVar597+D'5'
054C  3068  	MOVLW 0x68
054D  00B7  	MOVWF CompTempVar597+D'7'
054E  306C  	MOVLW 0x6C
054F  00B6  	MOVWF CompTempVar597+D'6'
0550  306D  	MOVLW 0x6D
0551  00B4  	MOVWF CompTempVar597+D'4'
0552  306F  	MOVLW 0x6F
0553  00B8  	MOVWF CompTempVar597+D'8'
0554  3072  	MOVLW 0x72
0555  00B3  	MOVWF CompTempVar597+D'3'
0556  01BF  	CLRF CompTempVar597+D'15'
0557  3000  	MOVLW HIGH(CompTempVar597+D'0')
0558  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0559  3030  	MOVLW LOW(CompTempVar597+D'0')
055A  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
055B  20A9  	CALL LCD_Printf_00000

		portb = 8;
055C  3008  	MOVLW 0x08
055D  0086  	MOVWF gbl_portb

		break;

		}
		
		case 1:	// Igual a 1..
052A  3A01  	XORLW 0x01
052B  1903  	BTFSC STATUS,Z
052C  2D5F  	GOTO	label61
055F        label61

		{
		lcd_gotoxy(5,1);
055F  3005  	MOVLW 0x05
0560  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0561  3001  	MOVLW 0x01
0562  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0563  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Verde         ");
0564  3020  	MOVLW 0x20
0565  00B0  	MOVWF CompTempVar599
0566  00B6  	MOVWF CompTempVar599+D'6'
0567  00B7  	MOVWF CompTempVar599+D'7'
0568  00B8  	MOVWF CompTempVar599+D'8'
0569  00B9  	MOVWF CompTempVar599+D'9'
056A  00BA  	MOVWF CompTempVar599+D'10'
056B  00BB  	MOVWF CompTempVar599+D'11'
056C  00BC  	MOVWF CompTempVar599+D'12'
056D  00BD  	MOVWF CompTempVar599+D'13'
056E  00BE  	MOVWF CompTempVar599+D'14'
056F  3056  	MOVLW 0x56
0570  00B1  	MOVWF CompTempVar599+D'1'
0571  3064  	MOVLW 0x64
0572  00B4  	MOVWF CompTempVar599+D'4'
0573  3065  	MOVLW 0x65
0574  00B2  	MOVWF CompTempVar599+D'2'
0575  00B5  	MOVWF CompTempVar599+D'5'
0576  3072  	MOVLW 0x72
0577  00B3  	MOVWF CompTempVar599+D'3'
0578  01BF  	CLRF CompTempVar599+D'15'
0579  3000  	MOVLW HIGH(CompTempVar599+D'0')
057A  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
057B  3030  	MOVLW LOW(CompTempVar599+D'0')
057C  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
057D  20A9  	CALL LCD_Printf_00000

		portb = 16;
057E  3010  	MOVLW 0x10
057F  0086  	MOVWF gbl_portb

		break;

		}
		
		case 2:
052D  3A03  	XORLW 0x03
052E  1903  	BTFSC STATUS,Z
052F  2D81  	GOTO	label62
0581        label62

		{
		lcd_gotoxy(5,1);
0581  3005  	MOVLW 0x05
0582  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0583  3001  	MOVLW 0x01
0584  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0585  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Azul          ");
0586  3020  	MOVLW 0x20
0587  00B0  	MOVWF CompTempVar601
0588  00B5  	MOVWF CompTempVar601+D'5'
0589  00B6  	MOVWF CompTempVar601+D'6'
058A  00B7  	MOVWF CompTempVar601+D'7'
058B  00B8  	MOVWF CompTempVar601+D'8'
058C  00B9  	MOVWF CompTempVar601+D'9'
058D  00BA  	MOVWF CompTempVar601+D'10'
058E  00BB  	MOVWF CompTempVar601+D'11'
058F  00BC  	MOVWF CompTempVar601+D'12'
0590  00BD  	MOVWF CompTempVar601+D'13'
0591  00BE  	MOVWF CompTempVar601+D'14'
0592  3041  	MOVLW 0x41
0593  00B1  	MOVWF CompTempVar601+D'1'
0594  306C  	MOVLW 0x6C
0595  00B4  	MOVWF CompTempVar601+D'4'
0596  3075  	MOVLW 0x75
0597  00B3  	MOVWF CompTempVar601+D'3'
0598  307A  	MOVLW 0x7A
0599  00B2  	MOVWF CompTempVar601+D'2'
059A  01BF  	CLRF CompTempVar601+D'15'
059B  3000  	MOVLW HIGH(CompTempVar601+D'0')
059C  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
059D  3030  	MOVLW LOW(CompTempVar601+D'0')
059E  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
059F  20A9  	CALL LCD_Printf_00000

		portb = 32;
05A0  3020  	MOVLW 0x20
05A1  0086  	MOVWF gbl_portb

		break;

		}
		
		case 3:
0530  3A01  	XORLW 0x01
0531  1903  	BTFSC STATUS,Z
0532  2DA3  	GOTO	label63
05A3        label63

		{
		lcd_gotoxy(5,1);
05A3  3005  	MOVLW 0x05
05A4  00AE  	MOVWF LCD_GotoXy_00000_arg_x
05A5  3001  	MOVLW 0x01
05A6  00AF  	MOVWF LCD_GotoXy_00000_arg_y
05A7  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Laranja       ");
05A8  3020  	MOVLW 0x20
05A9  00B0  	MOVWF CompTempVar603
05AA  00B8  	MOVWF CompTempVar603+D'8'
05AB  00B9  	MOVWF CompTempVar603+D'9'
05AC  00BA  	MOVWF CompTempVar603+D'10'
05AD  00BB  	MOVWF CompTempVar603+D'11'
05AE  00BC  	MOVWF CompTempVar603+D'12'
05AF  00BD  	MOVWF CompTempVar603+D'13'
05B0  00BE  	MOVWF CompTempVar603+D'14'
05B1  304C  	MOVLW 0x4C
05B2  00B1  	MOVWF CompTempVar603+D'1'
05B3  3061  	MOVLW 0x61
05B4  00B2  	MOVWF CompTempVar603+D'2'
05B5  00B4  	MOVWF CompTempVar603+D'4'
05B6  00B7  	MOVWF CompTempVar603+D'7'
05B7  306A  	MOVLW 0x6A
05B8  00B6  	MOVWF CompTempVar603+D'6'
05B9  306E  	MOVLW 0x6E
05BA  00B5  	MOVWF CompTempVar603+D'5'
05BB  3072  	MOVLW 0x72
05BC  00B3  	MOVWF CompTempVar603+D'3'
05BD  01BF  	CLRF CompTempVar603+D'15'
05BE  3000  	MOVLW HIGH(CompTempVar603+D'0')
05BF  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
05C0  3030  	MOVLW LOW(CompTempVar603+D'0')
05C1  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
05C2  20A9  	CALL LCD_Printf_00000

		portb= 56;
05C3  3038  	MOVLW 0x38
05C4  0086  	MOVWF gbl_portb

		break;

		}
			
		case 4:
0533  3A07  	XORLW 0x07
0534  1903  	BTFSC STATUS,Z
0535  2DC6  	GOTO	label64
05C6        label64

		{
		lcd_gotoxy(5,1);
05C6  3005  	MOVLW 0x05
05C7  00AE  	MOVWF LCD_GotoXy_00000_arg_x
05C8  3001  	MOVLW 0x01
05C9  00AF  	MOVWF LCD_GotoXy_00000_arg_y
05CA  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Roxo          ");
05CB  3020  	MOVLW 0x20
05CC  00B0  	MOVWF CompTempVar605
05CD  00B5  	MOVWF CompTempVar605+D'5'
05CE  00B6  	MOVWF CompTempVar605+D'6'
05CF  00B7  	MOVWF CompTempVar605+D'7'
05D0  00B8  	MOVWF CompTempVar605+D'8'
05D1  00B9  	MOVWF CompTempVar605+D'9'
05D2  00BA  	MOVWF CompTempVar605+D'10'
05D3  00BB  	MOVWF CompTempVar605+D'11'
05D4  00BC  	MOVWF CompTempVar605+D'12'
05D5  00BD  	MOVWF CompTempVar605+D'13'
05D6  00BE  	MOVWF CompTempVar605+D'14'
05D7  3052  	MOVLW 0x52
05D8  00B1  	MOVWF CompTempVar605+D'1'
05D9  306F  	MOVLW 0x6F
05DA  00B2  	MOVWF CompTempVar605+D'2'
05DB  00B4  	MOVWF CompTempVar605+D'4'
05DC  3078  	MOVLW 0x78
05DD  00B3  	MOVWF CompTempVar605+D'3'
05DE  01BF  	CLRF CompTempVar605+D'15'
05DF  3000  	MOVLW HIGH(CompTempVar605+D'0')
05E0  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
05E1  3030  	MOVLW LOW(CompTempVar605+D'0')
05E2  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
05E3  20A9  	CALL LCD_Printf_00000

		portb = 40;
05E4  3028  	MOVLW 0x28
05E5  0086  	MOVWF gbl_portb

		break;

		}
		
		case 5:
0536  3A01  	XORLW 0x01
0537  1903  	BTFSC STATUS,Z
0538  2DE7  	GOTO	label65
05E7        label65

		{
		lcd_gotoxy(5,1);
05E7  3005  	MOVLW 0x05
05E8  00AE  	MOVWF LCD_GotoXy_00000_arg_x
05E9  3001  	MOVLW 0x01
05EA  00AF  	MOVWF LCD_GotoXy_00000_arg_y
05EB  20CD  	CALL LCD_GotoXy_00000

			lprintf(" Ciano         ");
05EC  3020  	MOVLW 0x20
05ED  00B0  	MOVWF CompTempVar607
05EE  00B6  	MOVWF CompTempVar607+D'6'
05EF  00B7  	MOVWF CompTempVar607+D'7'
05F0  00B8  	MOVWF CompTempVar607+D'8'
05F1  00B9  	MOVWF CompTempVar607+D'9'
05F2  00BA  	MOVWF CompTempVar607+D'10'
05F3  00BB  	MOVWF CompTempVar607+D'11'
05F4  00BC  	MOVWF CompTempVar607+D'12'
05F5  00BD  	MOVWF CompTempVar607+D'13'
05F6  00BE  	MOVWF CompTempVar607+D'14'
05F7  3043  	MOVLW 0x43
05F8  00B1  	MOVWF CompTempVar607+D'1'
05F9  3061  	MOVLW 0x61
05FA  00B3  	MOVWF CompTempVar607+D'3'
05FB  3069  	MOVLW 0x69
05FC  00B2  	MOVWF CompTempVar607+D'2'
05FD  306E  	MOVLW 0x6E
05FE  00B4  	MOVWF CompTempVar607+D'4'
05FF  306F  	MOVLW 0x6F
0600  00B5  	MOVWF CompTempVar607+D'5'
0601  01BF  	CLRF CompTempVar607+D'15'
0602  3000  	MOVLW HIGH(CompTempVar607+D'0')
0603  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0604  3030  	MOVLW LOW(CompTempVar607+D'0')
0605  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0606  20A9  	CALL LCD_Printf_00000

		portb = 48;
0607  3030  	MOVLW 0x30
0608  0086  	MOVWF gbl_portb

		break;

		}
			}
	}
}
0522  0008  	RETURN
0525  0008  	RETURN
0539  0008  	RETURN
055E  0008  	RETURN
0580  0008  	RETURN
05A2  0008  	RETURN
05C5  0008  	RETURN
05E6  0008  	RETURN
0609  0008  	RETURN


void efeito()

{

if((estado == 1) && (controle == 2))
0342  1283  	BCF STATUS, RP0
0343  1303  	BCF STATUS, RP1
0344  0327  	DECF gbl_estado, W
0345  1D03  	BTFSS STATUS,Z
0347  0828  	MOVF gbl_controle, W
0348  3A02  	XORLW 0x02
0349  1D03  	BTFSS STATUS,Z

		{
		
		switch ( efeito )

			{
		case 0:
034B  082C  	MOVF gbl_efeito, W
034C  3A00  	XORLW 0x00
034D  1903  	BTFSC STATUS,Z
034E  2B5C  	GOTO	label30
035C        label30

		{
		lcd_gotoxy(9,1);
035C  3009  	MOVLW 0x09
035D  00AE  	MOVWF LCD_GotoXy_00000_arg_x
035E  3001  	MOVLW 0x01
035F  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0360  20CD  	CALL LCD_GotoXy_00000

			lprintf("Sequencial ");
0361  3020  	MOVLW 0x20
0362  00BA  	MOVWF CompTempVar609+D'10'
0363  3053  	MOVLW 0x53
0364  00B0  	MOVWF CompTempVar609
0365  3061  	MOVLW 0x61
0366  00B8  	MOVWF CompTempVar609+D'8'
0367  3063  	MOVLW 0x63
0368  00B6  	MOVWF CompTempVar609+D'6'
0369  3065  	MOVLW 0x65
036A  00B1  	MOVWF CompTempVar609+D'1'
036B  00B4  	MOVWF CompTempVar609+D'4'
036C  3069  	MOVLW 0x69
036D  00B7  	MOVWF CompTempVar609+D'7'
036E  306C  	MOVLW 0x6C
036F  00B9  	MOVWF CompTempVar609+D'9'
0370  306E  	MOVLW 0x6E
0371  00B5  	MOVWF CompTempVar609+D'5'
0372  3071  	MOVLW 0x71
0373  00B2  	MOVWF CompTempVar609+D'2'
0374  3075  	MOVLW 0x75
0375  00B3  	MOVWF CompTempVar609+D'3'
0376  01BB  	CLRF CompTempVar609+D'11'
0377  3000  	MOVLW HIGH(CompTempVar609+D'0')
0378  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0379  3030  	MOVLW LOW(CompTempVar609+D'0')
037A  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
037B  20A9  	CALL LCD_Printf_00000

		if(delay < 25)
037C  3019  	MOVLW 0x19
037D  0225  	SUBWF gbl_delay, W
037E  1803  	BTFSC STATUS,C
037F  2B82  	GOTO	label31
0382        label31

		portb = 8;
0380  3008  	MOVLW 0x08
0381  0086  	MOVWF gbl_portb

			if((delay > 25) && (delay < 50))
0382  0825  	MOVF gbl_delay, W
0383  3C19  	SUBLW 0x19
0384  1803  	BTFSC STATUS,C
0385  2B8C  	GOTO	label32
0386  3032  	MOVLW 0x32
0387  0225  	SUBWF gbl_delay, W
0388  1803  	BTFSC STATUS,C
0389  2B8C  	GOTO	label32
038C        label32

		portb = 16;
038A  3010  	MOVLW 0x10
038B  0086  	MOVWF gbl_portb

			if((delay > 50) && (delay < 75))
038C  0825  	MOVF gbl_delay, W
038D  3C32  	SUBLW 0x32
038E  1803  	BTFSC STATUS,C
038F  2B96  	GOTO	label33
0390  304B  	MOVLW 0x4B
0391  0225  	SUBWF gbl_delay, W
0392  1803  	BTFSC STATUS,C
0393  2B96  	GOTO	label33
0396        label33

		portb = 32;
0394  3020  	MOVLW 0x20
0395  0086  	MOVWF gbl_portb

			if((delay > 75) && (delay < 100))
0396  0825  	MOVF gbl_delay, W
0397  3C4B  	SUBLW 0x4B
0398  1803  	BTFSC STATUS,C
0399  2BA0  	GOTO	label34
039A  3064  	MOVLW 0x64
039B  0225  	SUBWF gbl_delay, W
039C  1803  	BTFSC STATUS,C
039D  2BA0  	GOTO	label34
03A0        label34

		portb = 56;
039E  3038  	MOVLW 0x38
039F  0086  	MOVWF gbl_portb

			if((delay > 100) && (delay < 125))
03A0  0825  	MOVF gbl_delay, W
03A1  3C64  	SUBLW 0x64
03A2  1803  	BTFSC STATUS,C
03A3  2BAA  	GOTO	label35
03A4  307D  	MOVLW 0x7D
03A5  0225  	SUBWF gbl_delay, W
03A6  1803  	BTFSC STATUS,C
03A7  2BAA  	GOTO	label35
03AA        label35

		portb = 40;
03A8  3028  	MOVLW 0x28
03A9  0086  	MOVWF gbl_portb

			if((delay > 125) && (delay < 150))
03AA  0825  	MOVF gbl_delay, W
03AB  3C7D  	SUBLW 0x7D
03AC  1803  	BTFSC STATUS,C
03AE  3096  	MOVLW 0x96
03AF  0225  	SUBWF gbl_delay, W
03B0  1803  	BTFSC STATUS,C

		portb = 48;
03B2  3030  	MOVLW 0x30
03B3  0086  	MOVWF gbl_portb

		break;

		}
		
		case 1:
034F  3A01  	XORLW 0x01
0350  1903  	BTFSC STATUS,Z
0351  2BB5  	GOTO	label36
03B5        label36

		{
		lcd_gotoxy(9,1);
03B5  3009  	MOVLW 0x09
03B6  00AE  	MOVWF LCD_GotoXy_00000_arg_x
03B7  3001  	MOVLW 0x01
03B8  00AF  	MOVWF LCD_GotoXy_00000_arg_y
03B9  20CD  	CALL LCD_GotoXy_00000

			lprintf("Psicodelico");
03BA  3050  	MOVLW 0x50
03BB  00B0  	MOVWF CompTempVar611
03BC  3063  	MOVLW 0x63
03BD  00B3  	MOVWF CompTempVar611+D'3'
03BE  00B9  	MOVWF CompTempVar611+D'9'
03BF  3064  	MOVLW 0x64
03C0  00B5  	MOVWF CompTempVar611+D'5'
03C1  3065  	MOVLW 0x65
03C2  00B6  	MOVWF CompTempVar611+D'6'
03C3  3069  	MOVLW 0x69
03C4  00B2  	MOVWF CompTempVar611+D'2'
03C5  00B8  	MOVWF CompTempVar611+D'8'
03C6  306C  	MOVLW 0x6C
03C7  00B7  	MOVWF CompTempVar611+D'7'
03C8  306F  	MOVLW 0x6F
03C9  00B4  	MOVWF CompTempVar611+D'4'
03CA  00BA  	MOVWF CompTempVar611+D'10'
03CB  3073  	MOVLW 0x73
03CC  00B1  	MOVWF CompTempVar611+D'1'
03CD  01BB  	CLRF CompTempVar611+D'11'
03CE  3000  	MOVLW HIGH(CompTempVar611+D'0')
03CF  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
03D0  3030  	MOVLW LOW(CompTempVar611+D'0')
03D1  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
03D2  20A9  	CALL LCD_Printf_00000

		if(delay < 20)
03D3  3014  	MOVLW 0x14
03D4  0225  	SUBWF gbl_delay, W
03D5  1803  	BTFSC STATUS,C
03D6  2BD9  	GOTO	label37
03D9        label37

		portb = 1 * delay;
03D7  0825  	MOVF gbl_delay, W
03D8  0086  	MOVWF gbl_portb

			if((delay > 20) && (delay < 40))
03D9  0825  	MOVF gbl_delay, W
03DA  3C14  	SUBLW 0x14
03DB  1803  	BTFSC STATUS,C
03DC  2BE4  	GOTO	label38
03DD  3028  	MOVLW 0x28
03DE  0225  	SUBWF gbl_delay, W
03DF  1803  	BTFSC STATUS,C
03E0  2BE4  	GOTO	label38
03E4        label38

		portb = 16 * delay;
03E1  0E25  	SWAPF gbl_delay, W
03E2  39F0  	ANDLW 0xF0
03E3  0086  	MOVWF gbl_portb

			if((delay > 40) && (delay < 60))
03E4  0825  	MOVF gbl_delay, W
03E5  3C28  	SUBLW 0x28
03E6  1803  	BTFSC STATUS,C
03E7  2BF6  	GOTO	label39
03E8  303C  	MOVLW 0x3C
03E9  0225  	SUBWF gbl_delay, W
03EA  1803  	BTFSC STATUS,C
03EB  2BF6  	GOTO	label39
03F6        label39

		portb = 32 * delay;
03EC  0825  	MOVF gbl_delay, W
03ED  00AE  	MOVWF CompTempVar613
03EE  0DAE  	RLF CompTempVar613, F
03EF  0DAE  	RLF CompTempVar613, F
03F0  0DAE  	RLF CompTempVar613, F
03F1  0DAE  	RLF CompTempVar613, F
03F2  0DAE  	RLF CompTempVar613, F
03F3  30E0  	MOVLW 0xE0
03F4  052E  	ANDWF CompTempVar613, W
03F5  0086  	MOVWF gbl_portb

			if((delay > 60) && (delay < 80))
03F6  0825  	MOVF gbl_delay, W
03F7  3C3C  	SUBLW 0x3C
03F8  1803  	BTFSC STATUS,C
03F9  2C05  	GOTO	label40
03FA  3050  	MOVLW 0x50
03FB  0225  	SUBWF gbl_delay, W
03FC  1803  	BTFSC STATUS,C
03FD  2C05  	GOTO	label40
0405        label40

		portb = 56 * delay;
03FE  3038  	MOVLW 0x38
03FF  00AE  	MOVWF __mul_8_8__00005_arg_a
0400  0825  	MOVF gbl_delay, W
0401  00AF  	MOVWF __mul_8_8__00005_arg_b
0402  2085  	CALL __mul_8_8__00005
0403  0831  	MOVF CompTempVarRet373, W
0404  0086  	MOVWF gbl_portb

			if((delay > 80) && (delay < 100))
0405  0825  	MOVF gbl_delay, W
0406  3C50  	SUBLW 0x50
0407  1803  	BTFSC STATUS,C
0408  2C14  	GOTO	label41
0409  3064  	MOVLW 0x64
040A  0225  	SUBWF gbl_delay, W
040B  1803  	BTFSC STATUS,C
040C  2C14  	GOTO	label41
0414        label41

		portb = 40 * delay;
040D  3028  	MOVLW 0x28
040E  00AE  	MOVWF __mul_8_8__00005_arg_a
040F  0825  	MOVF gbl_delay, W
0410  00AF  	MOVWF __mul_8_8__00005_arg_b
0411  2085  	CALL __mul_8_8__00005
0412  0831  	MOVF CompTempVarRet373, W
0413  0086  	MOVWF gbl_portb

			if((delay > 100) && (delay < 120))
0414  0825  	MOVF gbl_delay, W
0415  3C64  	SUBLW 0x64
0416  1803  	BTFSC STATUS,C
0418  3078  	MOVLW 0x78
0419  0225  	SUBWF gbl_delay, W
041A  1803  	BTFSC STATUS,C

		portb = 48 * delay;
041C  3030  	MOVLW 0x30
041D  00AE  	MOVWF __mul_8_8__00005_arg_a
041E  0825  	MOVF gbl_delay, W
041F  00AF  	MOVWF __mul_8_8__00005_arg_b
0420  2085  	CALL __mul_8_8__00005
0421  0831  	MOVF CompTempVarRet373, W
0422  0086  	MOVWF gbl_portb

		break;

		}
		
		case 2:
0352  3A03  	XORLW 0x03
0353  1903  	BTFSC STATUS,Z
0354  2C24  	GOTO	label42
0424        label42

		{
		lcd_gotoxy(9,1);
0424  3009  	MOVLW 0x09
0425  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0426  3001  	MOVLW 0x01
0427  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0428  20CD  	CALL LCD_GotoXy_00000

			lprintf("Pisca-Red  ");
0429  3050  	MOVLW 0x50
042A  00B0  	MOVWF CompTempVar614
042B  3069  	MOVLW 0x69
042C  00B1  	MOVWF CompTempVar614+D'1'
042D  3073  	MOVLW 0x73
042E  00B2  	MOVWF CompTempVar614+D'2'
042F  3063  	MOVLW 0x63
0430  00B3  	MOVWF CompTempVar614+D'3'
0431  3061  	MOVLW 0x61
0432  00B4  	MOVWF CompTempVar614+D'4'
0433  302D  	MOVLW 0x2D
0434  00B5  	MOVWF CompTempVar614+D'5'
0435  3052  	MOVLW 0x52
0436  00B6  	MOVWF CompTempVar614+D'6'
0437  3065  	MOVLW 0x65
0438  00B7  	MOVWF CompTempVar614+D'7'
0439  3064  	MOVLW 0x64
043A  00B8  	MOVWF CompTempVar614+D'8'
043B  3020  	MOVLW 0x20
043C  00B9  	MOVWF CompTempVar614+D'9'
043D  00BA  	MOVWF CompTempVar614+D'10'
043E  01BB  	CLRF CompTempVar614+D'11'
043F  3000  	MOVLW HIGH(CompTempVar614+D'0')
0440  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0441  3030  	MOVLW LOW(CompTempVar614+D'0')
0442  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0443  20A9  	CALL LCD_Printf_00000

			if(delay < 20)
0444  3014  	MOVLW 0x14
0445  0225  	SUBWF gbl_delay, W
0446  1803  	BTFSC STATUS,C
0447  2C4A  	GOTO	label43
044A        label43

		portb = 8;
0448  3008  	MOVLW 0x08
0449  0086  	MOVWF gbl_portb

			if((delay > 20) && (delay < 40))
044A  0825  	MOVF gbl_delay, W
044B  3C14  	SUBLW 0x14
044C  1803  	BTFSC STATUS,C
044D  2C52  	GOTO	label44
044E  3028  	MOVLW 0x28
044F  0225  	SUBWF gbl_delay, W
0450  1C03  	BTFSS STATUS,C

		portb = 0;
0451  0186  	CLRF gbl_portb
0452        label44

			if((delay > 40) && (delay < 60))
0452  0825  	MOVF gbl_delay, W
0453  3C28  	SUBLW 0x28
0454  1803  	BTFSC STATUS,C
0455  2C5C  	GOTO	label45
0456  303C  	MOVLW 0x3C
0457  0225  	SUBWF gbl_delay, W
0458  1803  	BTFSC STATUS,C
0459  2C5C  	GOTO	label45
045C        label45

		portb = 8;
045A  3008  	MOVLW 0x08
045B  0086  	MOVWF gbl_portb

			if((delay > 60) && (delay < 80))
045C  0825  	MOVF gbl_delay, W
045D  3C3C  	SUBLW 0x3C
045E  1803  	BTFSC STATUS,C
045F  2C64  	GOTO	label46
0460  3050  	MOVLW 0x50
0461  0225  	SUBWF gbl_delay, W
0462  1C03  	BTFSS STATUS,C

		portb = 0;
0463  0186  	CLRF gbl_portb
0464        label46

			if((delay > 80) && (delay < 100))
0464  0825  	MOVF gbl_delay, W
0465  3C50  	SUBLW 0x50
0466  1803  	BTFSC STATUS,C
0467  2C6E  	GOTO	label47
0468  3064  	MOVLW 0x64
0469  0225  	SUBWF gbl_delay, W
046A  1803  	BTFSC STATUS,C
046B  2C6E  	GOTO	label47
046E        label47

		portb = 8;
046C  3008  	MOVLW 0x08
046D  0086  	MOVWF gbl_portb

			if((delay > 100) && (delay < 120))
046E  0825  	MOVF gbl_delay, W
046F  3C64  	SUBLW 0x64
0470  1803  	BTFSC STATUS,C
0472  3078  	MOVLW 0x78
0473  0225  	SUBWF gbl_delay, W
0474  1C03  	BTFSS STATUS,C

		portb = 0;
0475  0186  	CLRF gbl_portb

		break;

		}
		
		case 3:
0355  3A01  	XORLW 0x01
0356  1903  	BTFSC STATUS,Z
0357  2C77  	GOTO	label48
0477        label48

		{
		lcd_gotoxy(9,1);
0477  3009  	MOVLW 0x09
0478  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0479  3001  	MOVLW 0x01
047A  00AF  	MOVWF LCD_GotoXy_00000_arg_y
047B  20CD  	CALL LCD_GotoXy_00000

			lprintf("Pisca-Green");
047C  3050  	MOVLW 0x50
047D  00B0  	MOVWF CompTempVar616
047E  3069  	MOVLW 0x69
047F  00B1  	MOVWF CompTempVar616+D'1'
0480  3073  	MOVLW 0x73
0481  00B2  	MOVWF CompTempVar616+D'2'
0482  3063  	MOVLW 0x63
0483  00B3  	MOVWF CompTempVar616+D'3'
0484  3061  	MOVLW 0x61
0485  00B4  	MOVWF CompTempVar616+D'4'
0486  302D  	MOVLW 0x2D
0487  00B5  	MOVWF CompTempVar616+D'5'
0488  3047  	MOVLW 0x47
0489  00B6  	MOVWF CompTempVar616+D'6'
048A  3072  	MOVLW 0x72
048B  00B7  	MOVWF CompTempVar616+D'7'
048C  3065  	MOVLW 0x65
048D  00B8  	MOVWF CompTempVar616+D'8'
048E  00B9  	MOVWF CompTempVar616+D'9'
048F  306E  	MOVLW 0x6E
0490  00BA  	MOVWF CompTempVar616+D'10'
0491  01BB  	CLRF CompTempVar616+D'11'
0492  3000  	MOVLW HIGH(CompTempVar616+D'0')
0493  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0494  3030  	MOVLW LOW(CompTempVar616+D'0')
0495  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0496  20A9  	CALL LCD_Printf_00000

		if(delay < 20)
0497  3014  	MOVLW 0x14
0498  0225  	SUBWF gbl_delay, W
0499  1803  	BTFSC STATUS,C
049A  2C9D  	GOTO	label49
049D        label49

		portb = 16;
049B  3010  	MOVLW 0x10
049C  0086  	MOVWF gbl_portb

			if((delay > 20) && (delay < 40))
049D  0825  	MOVF gbl_delay, W
049E  3C14  	SUBLW 0x14
049F  1803  	BTFSC STATUS,C
04A0  2CA5  	GOTO	label50
04A1  3028  	MOVLW 0x28
04A2  0225  	SUBWF gbl_delay, W
04A3  1C03  	BTFSS STATUS,C

		portb = 0;
04A4  0186  	CLRF gbl_portb
04A5        label50

			if((delay > 40) && (delay < 60))
04A5  0825  	MOVF gbl_delay, W
04A6  3C28  	SUBLW 0x28
04A7  1803  	BTFSC STATUS,C
04A8  2CAF  	GOTO	label51
04A9  303C  	MOVLW 0x3C
04AA  0225  	SUBWF gbl_delay, W
04AB  1803  	BTFSC STATUS,C
04AC  2CAF  	GOTO	label51
04AF        label51

		portb = 16;
04AD  3010  	MOVLW 0x10
04AE  0086  	MOVWF gbl_portb

			if((delay > 60) && (delay < 80))
04AF  0825  	MOVF gbl_delay, W
04B0  3C3C  	SUBLW 0x3C
04B1  1803  	BTFSC STATUS,C
04B2  2CB7  	GOTO	label52
04B3  3050  	MOVLW 0x50
04B4  0225  	SUBWF gbl_delay, W
04B5  1C03  	BTFSS STATUS,C

		portb = 0;
04B6  0186  	CLRF gbl_portb
04B7        label52

			if((delay > 80) && (delay < 100))
04B7  0825  	MOVF gbl_delay, W
04B8  3C50  	SUBLW 0x50
04B9  1803  	BTFSC STATUS,C
04BA  2CC1  	GOTO	label53
04BB  3064  	MOVLW 0x64
04BC  0225  	SUBWF gbl_delay, W
04BD  1803  	BTFSC STATUS,C
04BE  2CC1  	GOTO	label53
04C1        label53

		portb = 16;
04BF  3010  	MOVLW 0x10
04C0  0086  	MOVWF gbl_portb

			if((delay > 100) && (delay < 120))
04C1  0825  	MOVF gbl_delay, W
04C2  3C64  	SUBLW 0x64
04C3  1803  	BTFSC STATUS,C
04C5  3078  	MOVLW 0x78
04C6  0225  	SUBWF gbl_delay, W
04C7  1C03  	BTFSS STATUS,C

		portb = 0;
04C8  0186  	CLRF gbl_portb

		break;

		}
		
		case 4:
0358  3A07  	XORLW 0x07
0359  1903  	BTFSC STATUS,Z
035A  2CCA  	GOTO	label54
04CA        label54

		{
		lcd_gotoxy(9,1);
04CA  3009  	MOVLW 0x09
04CB  00AE  	MOVWF LCD_GotoXy_00000_arg_x
04CC  3001  	MOVLW 0x01
04CD  00AF  	MOVWF LCD_GotoXy_00000_arg_y
04CE  20CD  	CALL LCD_GotoXy_00000

			lprintf("Pisca-Blue ");
04CF  3050  	MOVLW 0x50
04D0  00B0  	MOVWF CompTempVar618
04D1  3069  	MOVLW 0x69
04D2  00B1  	MOVWF CompTempVar618+D'1'
04D3  3073  	MOVLW 0x73
04D4  00B2  	MOVWF CompTempVar618+D'2'
04D5  3063  	MOVLW 0x63
04D6  00B3  	MOVWF CompTempVar618+D'3'
04D7  3061  	MOVLW 0x61
04D8  00B4  	MOVWF CompTempVar618+D'4'
04D9  302D  	MOVLW 0x2D
04DA  00B5  	MOVWF CompTempVar618+D'5'
04DB  3042  	MOVLW 0x42
04DC  00B6  	MOVWF CompTempVar618+D'6'
04DD  306C  	MOVLW 0x6C
04DE  00B7  	MOVWF CompTempVar618+D'7'
04DF  3075  	MOVLW 0x75
04E0  00B8  	MOVWF CompTempVar618+D'8'
04E1  3065  	MOVLW 0x65
04E2  00B9  	MOVWF CompTempVar618+D'9'
04E3  3020  	MOVLW 0x20
04E4  00BA  	MOVWF CompTempVar618+D'10'
04E5  01BB  	CLRF CompTempVar618+D'11'
04E6  3000  	MOVLW HIGH(CompTempVar618+D'0')
04E7  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
04E8  3030  	MOVLW LOW(CompTempVar618+D'0')
04E9  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
04EA  20A9  	CALL LCD_Printf_00000

		if(delay < 20)
04EB  3014  	MOVLW 0x14
04EC  0225  	SUBWF gbl_delay, W
04ED  1803  	BTFSC STATUS,C
04EE  2CF1  	GOTO	label55
04F1        label55

		portb = 32;
04EF  3020  	MOVLW 0x20
04F0  0086  	MOVWF gbl_portb

			if((delay > 20) && (delay < 40))
04F1  0825  	MOVF gbl_delay, W
04F2  3C14  	SUBLW 0x14
04F3  1803  	BTFSC STATUS,C
04F4  2CF9  	GOTO	label56
04F5  3028  	MOVLW 0x28
04F6  0225  	SUBWF gbl_delay, W
04F7  1C03  	BTFSS STATUS,C

		portb = 0;
04F8  0186  	CLRF gbl_portb
04F9        label56

			if((delay > 40) && (delay < 60))
04F9  0825  	MOVF gbl_delay, W
04FA  3C28  	SUBLW 0x28
04FB  1803  	BTFSC STATUS,C
04FC  2D03  	GOTO	label57
04FD  303C  	MOVLW 0x3C
04FE  0225  	SUBWF gbl_delay, W
04FF  1803  	BTFSC STATUS,C
0500  2D03  	GOTO	label57
0503        label57

		portb = 32;
0501  3020  	MOVLW 0x20
0502  0086  	MOVWF gbl_portb

			if((delay > 60) && (delay < 80))
0503  0825  	MOVF gbl_delay, W
0504  3C3C  	SUBLW 0x3C
0505  1803  	BTFSC STATUS,C
0506  2D0B  	GOTO	label58
0507  3050  	MOVLW 0x50
0508  0225  	SUBWF gbl_delay, W
0509  1C03  	BTFSS STATUS,C

		portb = 0;
050A  0186  	CLRF gbl_portb
050B        label58

			if((delay > 80) && (delay < 100))
050B  0825  	MOVF gbl_delay, W
050C  3C50  	SUBLW 0x50
050D  1803  	BTFSC STATUS,C
050E  2D15  	GOTO	label59
050F  3064  	MOVLW 0x64
0510  0225  	SUBWF gbl_delay, W
0511  1803  	BTFSC STATUS,C
0512  2D15  	GOTO	label59
0515        label59

		portb = 32;
0513  3020  	MOVLW 0x20
0514  0086  	MOVWF gbl_portb

			if((delay > 100) && (delay < 120))
0515  0825  	MOVF gbl_delay, W
0516  3C64  	SUBLW 0x64
0517  1803  	BTFSC STATUS,C
0519  3078  	MOVLW 0x78
051A  0225  	SUBWF gbl_delay, W
051B  1C03  	BTFSS STATUS,C

		portb = 0;
051C  0186  	CLRF gbl_portb

		break;

		}
		}
	}
}
0346  0008  	RETURN
034A  0008  	RETURN
035B  0008  	RETURN
03AD  0008  	RETURN
03B1  0008  	RETURN
03B4  0008  	RETURN
0417  0008  	RETURN
041B  0008  	RETURN
0423  0008  	RETURN
0471  0008  	RETURN
0476  0008  	RETURN
04C4  0008  	RETURN
04C9  0008  	RETURN
0518  0008  	RETURN
051D  0008  	RETURN


void escreve()

{
	if(estado == 1)
0136  1283  	BCF STATUS, RP0
0137  1303  	BCF STATUS, RP1
0138  0327  	DECF gbl_estado, W
0139  1D03  	BTFSS STATUS,Z
013A  2B3E  	GOTO	label29

		{
			lcd_gotoxy(0,2);
013B  01AE  	CLRF LCD_GotoXy_00000_arg_x
013C  3002  	MOVLW 0x02
013D  00AF  	MOVWF LCD_GotoXy_00000_arg_y
013E  20CD  	CALL LCD_GotoXy_00000

			lprintf("Modo :");
013F  3020  	MOVLW 0x20
0140  00B4  	MOVWF CompTempVar563+D'4'
0141  303A  	MOVLW 0x3A
0142  00B5  	MOVWF CompTempVar563+D'5'
0143  304D  	MOVLW 0x4D
0144  00B0  	MOVWF CompTempVar563
0145  3064  	MOVLW 0x64
0146  00B2  	MOVWF CompTempVar563+D'2'
0147  306F  	MOVLW 0x6F
0148  00B1  	MOVWF CompTempVar563+D'1'
0149  00B3  	MOVWF CompTempVar563+D'3'
014A  01B6  	CLRF CompTempVar563+D'6'
014B  3000  	MOVLW HIGH(CompTempVar563+D'0')
014C  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
014D  3030  	MOVLW LOW(CompTempVar563+D'0')
014E  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
014F  20A9  	CALL LCD_Printf_00000

			
			if(contador < 120)
0150  3078  	MOVLW 0x78
0151  0224  	SUBWF gbl_contador, W
0152  1803  	BTFSC STATUS,C
0153  297C  	GOTO	label19
017C        label19

			{
			lcd_gotoxy(0,0);
0154  01AE  	CLRF LCD_GotoXy_00000_arg_x
0155  01AF  	CLRF LCD_GotoXy_00000_arg_y
0156  20CD  	CALL LCD_GotoXy_00000

			lprintf("     LED Shower     ");
0157  3020  	MOVLW 0x20
0158  00B0  	MOVWF CompTempVar565
0159  00B1  	MOVWF CompTempVar565+D'1'
015A  00B2  	MOVWF CompTempVar565+D'2'
015B  00B3  	MOVWF CompTempVar565+D'3'
015C  00B4  	MOVWF CompTempVar565+D'4'
015D  00B8  	MOVWF CompTempVar565+D'8'
015E  00BF  	MOVWF CompTempVar565+D'15'
015F  00C0  	MOVWF CompTempVar565+D'16'
0160  00C1  	MOVWF CompTempVar565+D'17'
0161  00C2  	MOVWF CompTempVar565+D'18'
0162  00C3  	MOVWF CompTempVar565+D'19'
0163  3044  	MOVLW 0x44
0164  00B7  	MOVWF CompTempVar565+D'7'
0165  3045  	MOVLW 0x45
0166  00B6  	MOVWF CompTempVar565+D'6'
0167  304C  	MOVLW 0x4C
0168  00B5  	MOVWF CompTempVar565+D'5'
0169  3053  	MOVLW 0x53
016A  00B9  	MOVWF CompTempVar565+D'9'
016B  3065  	MOVLW 0x65
016C  00BD  	MOVWF CompTempVar565+D'13'
016D  3068  	MOVLW 0x68
016E  00BA  	MOVWF CompTempVar565+D'10'
016F  306F  	MOVLW 0x6F
0170  00BB  	MOVWF CompTempVar565+D'11'
0171  3072  	MOVLW 0x72
0172  00BE  	MOVWF CompTempVar565+D'14'
0173  3077  	MOVLW 0x77
0174  00BC  	MOVWF CompTempVar565+D'12'
0175  01C4  	CLRF CompTempVar565+D'20'
0176  3000  	MOVLW HIGH(CompTempVar565+D'0')
0177  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0178  3030  	MOVLW LOW(CompTempVar565+D'0')
0179  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
017A  20A9  	CALL LCD_Printf_00000

			}
			else
017B  299A  	GOTO	label20
019A        label20

				{
			lcd_gotoxy(0,0);
017C  01AE  	CLRF LCD_GotoXy_00000_arg_x
017D  01AF  	CLRF LCD_GotoXy_00000_arg_y
017E  20CD  	CALL LCD_GotoXy_00000

			lprintf("                    ");
017F  3020  	MOVLW 0x20
0180  00B0  	MOVWF CompTempVar567
0181  00B1  	MOVWF CompTempVar567+D'1'
0182  00B2  	MOVWF CompTempVar567+D'2'
0183  00B3  	MOVWF CompTempVar567+D'3'
0184  00B4  	MOVWF CompTempVar567+D'4'
0185  00B5  	MOVWF CompTempVar567+D'5'
0186  00B6  	MOVWF CompTempVar567+D'6'
0187  00B7  	MOVWF CompTempVar567+D'7'
0188  00B8  	MOVWF CompTempVar567+D'8'
0189  00B9  	MOVWF CompTempVar567+D'9'
018A  00BA  	MOVWF CompTempVar567+D'10'
018B  00BB  	MOVWF CompTempVar567+D'11'
018C  00BC  	MOVWF CompTempVar567+D'12'
018D  00BD  	MOVWF CompTempVar567+D'13'
018E  00BE  	MOVWF CompTempVar567+D'14'
018F  00BF  	MOVWF CompTempVar567+D'15'
0190  00C0  	MOVWF CompTempVar567+D'16'
0191  00C1  	MOVWF CompTempVar567+D'17'
0192  00C2  	MOVWF CompTempVar567+D'18'
0193  00C3  	MOVWF CompTempVar567+D'19'
0194  01C4  	CLRF CompTempVar567+D'20'
0195  3000  	MOVLW HIGH(CompTempVar567+D'0')
0196  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0197  3030  	MOVLW LOW(CompTempVar567+D'0')
0198  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0199  20A9  	CALL LCD_Printf_00000

				}
			
		if(segundo == 0)
019A  08A6  	MOVF gbl_segundo, F
019B  1D03  	BTFSS STATUS,Z
019C  29B2  	GOTO	label21
01B2        label21

			{
			lcd_gotoxy(15,3);
019D  300F  	MOVLW 0x0F
019E  00AE  	MOVWF LCD_GotoXy_00000_arg_x
019F  3003  	MOVLW 0x03
01A0  00AF  	MOVWF LCD_GotoXy_00000_arg_y
01A1  20CD  	CALL LCD_GotoXy_00000

			lprintf("Julio");
01A2  304A  	MOVLW 0x4A
01A3  00B0  	MOVWF CompTempVar569
01A4  3075  	MOVLW 0x75
01A5  00B1  	MOVWF CompTempVar569+D'1'
01A6  306C  	MOVLW 0x6C
01A7  00B2  	MOVWF CompTempVar569+D'2'
01A8  3069  	MOVLW 0x69
01A9  00B3  	MOVWF CompTempVar569+D'3'
01AA  306F  	MOVLW 0x6F
01AB  00B4  	MOVWF CompTempVar569+D'4'
01AC  01B5  	CLRF CompTempVar569+D'5'
01AD  3000  	MOVLW HIGH(CompTempVar569+D'0')
01AE  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
01AF  3030  	MOVLW LOW(CompTempVar569+D'0')
01B0  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
01B1  20A9  	CALL LCD_Printf_00000

			}
		if(segundo == 1)
01B2  0326  	DECF gbl_segundo, W
01B3  1D03  	BTFSS STATUS,Z
01B4  29D6  	GOTO	label22
01D6        label22

			{
			lcd_gotoxy(9,3);
01B5  3009  	MOVLW 0x09
01B6  00AE  	MOVWF LCD_GotoXy_00000_arg_x
01B7  3003  	MOVLW 0x03
01B8  00AF  	MOVWF LCD_GotoXy_00000_arg_y
01B9  20CD  	CALL LCD_GotoXy_00000

			lprintf("Julio Cesar");
01BA  304A  	MOVLW 0x4A
01BB  00B0  	MOVWF CompTempVar571
01BC  3075  	MOVLW 0x75
01BD  00B1  	MOVWF CompTempVar571+D'1'
01BE  306C  	MOVLW 0x6C
01BF  00B2  	MOVWF CompTempVar571+D'2'
01C0  3069  	MOVLW 0x69
01C1  00B3  	MOVWF CompTempVar571+D'3'
01C2  306F  	MOVLW 0x6F
01C3  00B4  	MOVWF CompTempVar571+D'4'
01C4  3020  	MOVLW 0x20
01C5  00B5  	MOVWF CompTempVar571+D'5'
01C6  3043  	MOVLW 0x43
01C7  00B6  	MOVWF CompTempVar571+D'6'
01C8  3065  	MOVLW 0x65
01C9  00B7  	MOVWF CompTempVar571+D'7'
01CA  3073  	MOVLW 0x73
01CB  00B8  	MOVWF CompTempVar571+D'8'
01CC  3061  	MOVLW 0x61
01CD  00B9  	MOVWF CompTempVar571+D'9'
01CE  3072  	MOVLW 0x72
01CF  00BA  	MOVWF CompTempVar571+D'10'
01D0  01BB  	CLRF CompTempVar571+D'11'
01D1  3000  	MOVLW HIGH(CompTempVar571+D'0')
01D2  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
01D3  3030  	MOVLW LOW(CompTempVar571+D'0')
01D4  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
01D5  20A9  	CALL LCD_Printf_00000

			}
		if(segundo == 2)
01D6  0826  	MOVF gbl_segundo, W
01D7  3A02  	XORLW 0x02
01D8  1D03  	BTFSS STATUS,Z
01D9  2A07  	GOTO	label23
0207        label23

			{
			lcd_gotoxy(0,3);
01DA  01AE  	CLRF LCD_GotoXy_00000_arg_x
01DB  3003  	MOVLW 0x03
01DC  00AF  	MOVWF LCD_GotoXy_00000_arg_y
01DD  20CD  	CALL LCD_GotoXy_00000

			lprintf("Julio Cesar Kochhann");
01DE  3020  	MOVLW 0x20
01DF  00B5  	MOVWF CompTempVar573+D'5'
01E0  00BB  	MOVWF CompTempVar573+D'11'
01E1  3043  	MOVLW 0x43
01E2  00B6  	MOVWF CompTempVar573+D'6'
01E3  304A  	MOVLW 0x4A
01E4  00B0  	MOVWF CompTempVar573
01E5  304B  	MOVLW 0x4B
01E6  00BC  	MOVWF CompTempVar573+D'12'
01E7  3061  	MOVLW 0x61
01E8  00B9  	MOVWF CompTempVar573+D'9'
01E9  00C1  	MOVWF CompTempVar573+D'17'
01EA  3063  	MOVLW 0x63
01EB  00BE  	MOVWF CompTempVar573+D'14'
01EC  3065  	MOVLW 0x65
01ED  00B7  	MOVWF CompTempVar573+D'7'
01EE  3068  	MOVLW 0x68
01EF  00BF  	MOVWF CompTempVar573+D'15'
01F0  00C0  	MOVWF CompTempVar573+D'16'
01F1  3069  	MOVLW 0x69
01F2  00B3  	MOVWF CompTempVar573+D'3'
01F3  306C  	MOVLW 0x6C
01F4  00B2  	MOVWF CompTempVar573+D'2'
01F5  306E  	MOVLW 0x6E
01F6  00C2  	MOVWF CompTempVar573+D'18'
01F7  00C3  	MOVWF CompTempVar573+D'19'
01F8  306F  	MOVLW 0x6F
01F9  00B4  	MOVWF CompTempVar573+D'4'
01FA  00BD  	MOVWF CompTempVar573+D'13'
01FB  3072  	MOVLW 0x72
01FC  00BA  	MOVWF CompTempVar573+D'10'
01FD  3073  	MOVLW 0x73
01FE  00B8  	MOVWF CompTempVar573+D'8'
01FF  3075  	MOVLW 0x75
0200  00B1  	MOVWF CompTempVar573+D'1'
0201  01C4  	CLRF CompTempVar573+D'20'
0202  3000  	MOVLW HIGH(CompTempVar573+D'0')
0203  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0204  3030  	MOVLW LOW(CompTempVar573+D'0')
0205  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0206  20A9  	CALL LCD_Printf_00000

			}
		if(segundo == 4)
0207  0826  	MOVF gbl_segundo, W
0208  3A04  	XORLW 0x04
0209  1D03  	BTFSS STATUS,Z
020A  2A2A  	GOTO	label24
022A        label24

			{
			lcd_gotoxy(0,3);
020B  01AE  	CLRF LCD_GotoXy_00000_arg_x
020C  3003  	MOVLW 0x03
020D  00AF  	MOVWF LCD_GotoXy_00000_arg_y
020E  20CD  	CALL LCD_GotoXy_00000

			lprintf("                    ");
020F  3020  	MOVLW 0x20
0210  00B0  	MOVWF CompTempVar575
0211  00B1  	MOVWF CompTempVar575+D'1'
0212  00B2  	MOVWF CompTempVar575+D'2'
0213  00B3  	MOVWF CompTempVar575+D'3'
0214  00B4  	MOVWF CompTempVar575+D'4'
0215  00B5  	MOVWF CompTempVar575+D'5'
0216  00B6  	MOVWF CompTempVar575+D'6'
0217  00B7  	MOVWF CompTempVar575+D'7'
0218  00B8  	MOVWF CompTempVar575+D'8'
0219  00B9  	MOVWF CompTempVar575+D'9'
021A  00BA  	MOVWF CompTempVar575+D'10'
021B  00BB  	MOVWF CompTempVar575+D'11'
021C  00BC  	MOVWF CompTempVar575+D'12'
021D  00BD  	MOVWF CompTempVar575+D'13'
021E  00BE  	MOVWF CompTempVar575+D'14'
021F  00BF  	MOVWF CompTempVar575+D'15'
0220  00C0  	MOVWF CompTempVar575+D'16'
0221  00C1  	MOVWF CompTempVar575+D'17'
0222  00C2  	MOVWF CompTempVar575+D'18'
0223  00C3  	MOVWF CompTempVar575+D'19'
0224  01C4  	CLRF CompTempVar575+D'20'
0225  3000  	MOVLW HIGH(CompTempVar575+D'0')
0226  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0227  3030  	MOVLW LOW(CompTempVar575+D'0')
0228  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0229  20A9  	CALL LCD_Printf_00000

			}
			
		if(controle == 0)
022A  08A8  	MOVF gbl_controle, F
022B  1D03  	BTFSS STATUS,Z
022C  2A4F  	GOTO	label25
024F        label25

			{
			lcd_gotoxy(7,2);
022D  3007  	MOVLW 0x07
022E  00AE  	MOVWF LCD_GotoXy_00000_arg_x
022F  3002  	MOVLW 0x02
0230  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0231  20CD  	CALL LCD_GotoXy_00000

			lprintf("Desativado  ");
0232  3020  	MOVLW 0x20
0233  00BA  	MOVWF CompTempVar577+D'10'
0234  00BB  	MOVWF CompTempVar577+D'11'
0235  3044  	MOVLW 0x44
0236  00B0  	MOVWF CompTempVar577
0237  3061  	MOVLW 0x61
0238  00B3  	MOVWF CompTempVar577+D'3'
0239  00B7  	MOVWF CompTempVar577+D'7'
023A  3064  	MOVLW 0x64
023B  00B8  	MOVWF CompTempVar577+D'8'
023C  3065  	MOVLW 0x65
023D  00B1  	MOVWF CompTempVar577+D'1'
023E  3069  	MOVLW 0x69
023F  00B5  	MOVWF CompTempVar577+D'5'
0240  306F  	MOVLW 0x6F
0241  00B9  	MOVWF CompTempVar577+D'9'
0242  3073  	MOVLW 0x73
0243  00B2  	MOVWF CompTempVar577+D'2'
0244  3074  	MOVLW 0x74
0245  00B4  	MOVWF CompTempVar577+D'4'
0246  3076  	MOVLW 0x76
0247  00B6  	MOVWF CompTempVar577+D'6'
0248  01BC  	CLRF CompTempVar577+D'12'
0249  3000  	MOVLW HIGH(CompTempVar577+D'0')
024A  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
024B  3030  	MOVLW LOW(CompTempVar577+D'0')
024C  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
024D  20A9  	CALL LCD_Printf_00000

			
			portb = 0;
024E  0186  	CLRF gbl_portb

			}
			
		if(controle == 1)
024F  0328  	DECF gbl_controle, W
0250  1D03  	BTFSS STATUS,Z
0251  2A83  	GOTO	label26
0283        label26

			{
			lcd_gotoxy(0,1);
0252  01AE  	CLRF LCD_GotoXy_00000_arg_x
0253  3001  	MOVLW 0x01
0254  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0255  20CD  	CALL LCD_GotoXy_00000

			lprintf("Cor :");
0256  3043  	MOVLW 0x43
0257  00B0  	MOVWF CompTempVar579
0258  306F  	MOVLW 0x6F
0259  00B1  	MOVWF CompTempVar579+D'1'
025A  3072  	MOVLW 0x72
025B  00B2  	MOVWF CompTempVar579+D'2'
025C  3020  	MOVLW 0x20
025D  00B3  	MOVWF CompTempVar579+D'3'
025E  303A  	MOVLW 0x3A
025F  00B4  	MOVWF CompTempVar579+D'4'
0260  01B5  	CLRF CompTempVar579+D'5'
0261  3000  	MOVLW HIGH(CompTempVar579+D'0')
0262  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0263  3030  	MOVLW LOW(CompTempVar579+D'0')
0264  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0265  20A9  	CALL LCD_Printf_00000

			
			lcd_gotoxy(7,2);
0266  3007  	MOVLW 0x07
0267  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0268  3002  	MOVLW 0x02
0269  00AF  	MOVWF LCD_GotoXy_00000_arg_y
026A  20CD  	CALL LCD_GotoXy_00000

			lprintf("Color        ");
026B  3020  	MOVLW 0x20
026C  00B5  	MOVWF CompTempVar581+D'5'
026D  00B6  	MOVWF CompTempVar581+D'6'
026E  00B7  	MOVWF CompTempVar581+D'7'
026F  00B8  	MOVWF CompTempVar581+D'8'
0270  00B9  	MOVWF CompTempVar581+D'9'
0271  00BA  	MOVWF CompTempVar581+D'10'
0272  00BB  	MOVWF CompTempVar581+D'11'
0273  00BC  	MOVWF CompTempVar581+D'12'
0274  3043  	MOVLW 0x43
0275  00B0  	MOVWF CompTempVar581
0276  306C  	MOVLW 0x6C
0277  00B2  	MOVWF CompTempVar581+D'2'
0278  306F  	MOVLW 0x6F
0279  00B1  	MOVWF CompTempVar581+D'1'
027A  00B3  	MOVWF CompTempVar581+D'3'
027B  3072  	MOVLW 0x72
027C  00B4  	MOVWF CompTempVar581+D'4'
027D  01BD  	CLRF CompTempVar581+D'13'
027E  3000  	MOVLW HIGH(CompTempVar581+D'0')
027F  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
0280  3030  	MOVLW LOW(CompTempVar581+D'0')
0281  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0282  20A9  	CALL LCD_Printf_00000

			}
			
		if(controle == 2)
0283  0828  	MOVF gbl_controle, W
0284  3A02  	XORLW 0x02
0285  1D03  	BTFSS STATUS,Z
0286  2AC0  	GOTO	label27
02C0        label27

			{
			lcd_gotoxy(0,1);
0287  01AE  	CLRF LCD_GotoXy_00000_arg_x
0288  3001  	MOVLW 0x01
0289  00AF  	MOVWF LCD_GotoXy_00000_arg_y
028A  20CD  	CALL LCD_GotoXy_00000

			lprintf("Efeito : ");
028B  3020  	MOVLW 0x20
028C  00B6  	MOVWF CompTempVar583+D'6'
028D  00B8  	MOVWF CompTempVar583+D'8'
028E  303A  	MOVLW 0x3A
028F  00B7  	MOVWF CompTempVar583+D'7'
0290  3045  	MOVLW 0x45
0291  00B0  	MOVWF CompTempVar583
0292  3065  	MOVLW 0x65
0293  00B2  	MOVWF CompTempVar583+D'2'
0294  3066  	MOVLW 0x66
0295  00B1  	MOVWF CompTempVar583+D'1'
0296  3069  	MOVLW 0x69
0297  00B3  	MOVWF CompTempVar583+D'3'
0298  306F  	MOVLW 0x6F
0299  00B5  	MOVWF CompTempVar583+D'5'
029A  3074  	MOVLW 0x74
029B  00B4  	MOVWF CompTempVar583+D'4'
029C  01B9  	CLRF CompTempVar583+D'9'
029D  3000  	MOVLW HIGH(CompTempVar583+D'0')
029E  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
029F  3030  	MOVLW LOW(CompTempVar583+D'0')
02A0  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
02A1  20A9  	CALL LCD_Printf_00000

			
			lcd_gotoxy(7,2);
02A2  3007  	MOVLW 0x07
02A3  00AE  	MOVWF LCD_GotoXy_00000_arg_x
02A4  3002  	MOVLW 0x02
02A5  00AF  	MOVWF LCD_GotoXy_00000_arg_y
02A6  20CD  	CALL LCD_GotoXy_00000

			lprintf("Effect       ");
02A7  3045  	MOVLW 0x45
02A8  00B0  	MOVWF CompTempVar585
02A9  3066  	MOVLW 0x66
02AA  00B1  	MOVWF CompTempVar585+D'1'
02AB  00B2  	MOVWF CompTempVar585+D'2'
02AC  3065  	MOVLW 0x65
02AD  00B3  	MOVWF CompTempVar585+D'3'
02AE  3063  	MOVLW 0x63
02AF  00B4  	MOVWF CompTempVar585+D'4'
02B0  3074  	MOVLW 0x74
02B1  00B5  	MOVWF CompTempVar585+D'5'
02B2  3020  	MOVLW 0x20
02B3  00B6  	MOVWF CompTempVar585+D'6'
02B4  00B7  	MOVWF CompTempVar585+D'7'
02B5  00B8  	MOVWF CompTempVar585+D'8'
02B6  00B9  	MOVWF CompTempVar585+D'9'
02B7  00BA  	MOVWF CompTempVar585+D'10'
02B8  00BB  	MOVWF CompTempVar585+D'11'
02B9  00BC  	MOVWF CompTempVar585+D'12'
02BA  01BD  	CLRF CompTempVar585+D'13'
02BB  3000  	MOVLW HIGH(CompTempVar585+D'0')
02BC  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
02BD  3030  	MOVLW LOW(CompTempVar585+D'0')
02BE  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
02BF  20A9  	CALL LCD_Printf_00000

			}
		
		if(controle == 3)
02C0  0828  	MOVF gbl_controle, W
02C1  3A03  	XORLW 0x03
02C2  1D03  	BTFSS STATUS,Z
02C3  2B3E  	GOTO	label29

			{
			lcd_gotoxy(7,2);
02C4  3007  	MOVLW 0x07
02C5  00AE  	MOVWF LCD_GotoXy_00000_arg_x
02C6  3002  	MOVLW 0x02
02C7  00AF  	MOVWF LCD_GotoXy_00000_arg_y
02C8  20CD  	CALL LCD_GotoXy_00000

			lprintf("Iluminacao   ");
02C9  3020  	MOVLW 0x20
02CA  00BA  	MOVWF CompTempVar587+D'10'
02CB  00BB  	MOVWF CompTempVar587+D'11'
02CC  00BC  	MOVWF CompTempVar587+D'12'
02CD  3049  	MOVLW 0x49
02CE  00B0  	MOVWF CompTempVar587
02CF  3061  	MOVLW 0x61
02D0  00B6  	MOVWF CompTempVar587+D'6'
02D1  00B8  	MOVWF CompTempVar587+D'8'
02D2  3063  	MOVLW 0x63
02D3  00B7  	MOVWF CompTempVar587+D'7'
02D4  3069  	MOVLW 0x69
02D5  00B4  	MOVWF CompTempVar587+D'4'
02D6  306C  	MOVLW 0x6C
02D7  00B1  	MOVWF CompTempVar587+D'1'
02D8  306D  	MOVLW 0x6D
02D9  00B3  	MOVWF CompTempVar587+D'3'
02DA  306E  	MOVLW 0x6E
02DB  00B5  	MOVWF CompTempVar587+D'5'
02DC  306F  	MOVLW 0x6F
02DD  00B9  	MOVWF CompTempVar587+D'9'
02DE  3075  	MOVLW 0x75
02DF  00B2  	MOVWF CompTempVar587+D'2'
02E0  01BD  	CLRF CompTempVar587+D'13'
02E1  3000  	MOVLW HIGH(CompTempVar587+D'0')
02E2  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
02E3  3030  	MOVLW LOW(CompTempVar587+D'0')
02E4  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
02E5  20A9  	CALL LCD_Printf_00000

			
			lcd_gotoxy(0,1);
02E6  01AE  	CLRF LCD_GotoXy_00000_arg_x
02E7  3001  	MOVLW 0x01
02E8  00AF  	MOVWF LCD_GotoXy_00000_arg_y
02E9  20CD  	CALL LCD_GotoXy_00000

			lprintf("Lampada : ");
02EA  3020  	MOVLW 0x20
02EB  00B7  	MOVWF CompTempVar589+D'7'
02EC  00B9  	MOVWF CompTempVar589+D'9'
02ED  303A  	MOVLW 0x3A
02EE  00B8  	MOVWF CompTempVar589+D'8'
02EF  304C  	MOVLW 0x4C
02F0  00B0  	MOVWF CompTempVar589
02F1  3061  	MOVLW 0x61
02F2  00B1  	MOVWF CompTempVar589+D'1'
02F3  00B4  	MOVWF CompTempVar589+D'4'
02F4  00B6  	MOVWF CompTempVar589+D'6'
02F5  3064  	MOVLW 0x64
02F6  00B5  	MOVWF CompTempVar589+D'5'
02F7  306D  	MOVLW 0x6D
02F8  00B2  	MOVWF CompTempVar589+D'2'
02F9  3070  	MOVLW 0x70
02FA  00B3  	MOVWF CompTempVar589+D'3'
02FB  01BA  	CLRF CompTempVar589+D'10'
02FC  3000  	MOVLW HIGH(CompTempVar589+D'0')
02FD  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
02FE  3030  	MOVLW LOW(CompTempVar589+D'0')
02FF  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
0300  20A9  	CALL LCD_Printf_00000

			
			if(lamp == 1)
0301  032D  	DECF gbl_lamp, W
0302  1D03  	BTFSS STATUS,Z
0303  2B20  	GOTO	label28
0320        label28

			{
			lcd_gotoxy(10,1);
0304  300A  	MOVLW 0x0A
0305  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0306  3001  	MOVLW 0x01
0307  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0308  20CD  	CALL LCD_GotoXy_00000

			lprintf("Ligada    ");
0309  3020  	MOVLW 0x20
030A  00B6  	MOVWF CompTempVar591+D'6'
030B  00B7  	MOVWF CompTempVar591+D'7'
030C  00B8  	MOVWF CompTempVar591+D'8'
030D  00B9  	MOVWF CompTempVar591+D'9'
030E  304C  	MOVLW 0x4C
030F  00B0  	MOVWF CompTempVar591
0310  3061  	MOVLW 0x61
0311  00B3  	MOVWF CompTempVar591+D'3'
0312  00B5  	MOVWF CompTempVar591+D'5'
0313  3064  	MOVLW 0x64
0314  00B4  	MOVWF CompTempVar591+D'4'
0315  3067  	MOVLW 0x67
0316  00B2  	MOVWF CompTempVar591+D'2'
0317  3069  	MOVLW 0x69
0318  00B1  	MOVWF CompTempVar591+D'1'
0319  01BA  	CLRF CompTempVar591+D'10'
031A  3000  	MOVLW HIGH(CompTempVar591+D'0')
031B  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
031C  3030  	MOVLW LOW(CompTempVar591+D'0')
031D  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
031E  20A9  	CALL LCD_Printf_00000

			}else
031F  2B3E  	GOTO	label29
033E        label29

			{
			lcd_gotoxy(10,1);
0320  300A  	MOVLW 0x0A
0321  00AE  	MOVWF LCD_GotoXy_00000_arg_x
0322  3001  	MOVLW 0x01
0323  00AF  	MOVWF LCD_GotoXy_00000_arg_y
0324  20CD  	CALL LCD_GotoXy_00000

			lprintf("Desligada ");
0325  3020  	MOVLW 0x20
0326  00B9  	MOVWF CompTempVar593+D'9'
0327  3044  	MOVLW 0x44
0328  00B0  	MOVWF CompTempVar593
0329  3061  	MOVLW 0x61
032A  00B6  	MOVWF CompTempVar593+D'6'
032B  00B8  	MOVWF CompTempVar593+D'8'
032C  3064  	MOVLW 0x64
032D  00B7  	MOVWF CompTempVar593+D'7'
032E  3065  	MOVLW 0x65
032F  00B1  	MOVWF CompTempVar593+D'1'
0330  3067  	MOVLW 0x67
0331  00B5  	MOVWF CompTempVar593+D'5'
0332  3069  	MOVLW 0x69
0333  00B4  	MOVWF CompTempVar593+D'4'
0334  306C  	MOVLW 0x6C
0335  00B3  	MOVWF CompTempVar593+D'3'
0336  3073  	MOVLW 0x73
0337  00B2  	MOVWF CompTempVar593+D'2'
0338  01BA  	CLRF CompTempVar593+D'10'
0339  3000  	MOVLW HIGH(CompTempVar593+D'0')
033A  00AF  	MOVWF LCD_Printf_00000_arg_lcdptr+D'1'
033B  3030  	MOVLW LOW(CompTempVar593+D'0')
033C  00AE  	MOVWF LCD_Printf_00000_arg_lcdptr
033D  20A9  	CALL LCD_Printf_00000

			}
		}
	}
			if(estado == 0)	
033E  08A7  	MOVF gbl_estado, F
033F  1903  	BTFSC STATUS,Z

			lcd_clear();
0340  20DD  	CALL LCD_Clear_00000

}
0341  0008  	RETURN

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  2F11  	GOTO	_startup

0004  00FF  	MOVWF Int1Context
0005  0E03  	SWAPF STATUS, W
0006  1283  	BCF STATUS, RP0
0007  1303  	BCF STATUS, RP1
0008  00A0  	MOVWF Int1BContext
0009  0E0A  	SWAPF PCLATH, W
000A  00A1  	MOVWF Int1BContext+D'1'
000B  0E04  	SWAPF FSR, W
000C  00A2  	MOVWF Int1BContext+D'2'
000D  118A  	BCF PCLATH,3
000E  120A  	BCF PCLATH,4
000F  2F14  	GOTO	interrupt
0010        delay_ms_00000
0010        ; { delay_ms ; function begin
0010  08AE  	MOVF delay_ms_00000_arg_del, F
0011  1D03  	BTFSS STATUS,Z
0012  2814  	GOTO	label1
0013  0008  	RETURN
0014        label1
0014  30F9  	MOVLW 0xF9
0015        label2
0015  3EFF  	ADDLW 0xFF
0016  1D03  	BTFSS STATUS,Z
0017  2815  	GOTO	label2
0018  0000  	NOP
0019  0BAE  	DECFSZ delay_ms_00000_arg_del, F
001A  2814  	GOTO	label1
001B  0008  	RETURN
001C        ; } delay_ms function end

001C        delay_10us_00000
001C        ; { delay_10us ; function begin
001C        label3
001C  0000  	NOP
001D  0000  	NOP
001E  0000  	NOP
001F  0000  	NOP
0020  0000  	NOP
0021  0000  	NOP
0022  0000  	NOP
0023  0BAE  	DECFSZ delay_10us_00000_arg_del, F
0024  281C  	GOTO	label3
0025  0008  	RETURN
0026        ; } delay_10us function end


0085        __mul_8_8__00005
0085        ; { __mul_8_8__8 ; function begin
0085  01B0  	CLRF __mul_8_8__00005_1_i
0086  01B1  	CLRF CompTempVarRet373
0087        label8
0087  19B0  	BTFSC __mul_8_8__00005_1_i,3
0088  0008  	RETURN
0089  1C2F  	BTFSS __mul_8_8__00005_arg_b,0
008A  288D  	GOTO	label9
008B  082E  	MOVF __mul_8_8__00005_arg_a, W
008C  07B1  	ADDWF CompTempVarRet373, F
008D        label9
008D  0CAF  	RRF __mul_8_8__00005_arg_b, F
008E  1003  	BCF gbl_status,0
008F  0DAE  	RLF __mul_8_8__00005_arg_a, F
0090  0AB0  	INCF __mul_8_8__00005_1_i, F
0091  2887  	GOTO	label8
0092        ; } __mul_8_8__8 function end















0711        _startup
0711  118A  	BCF PCLATH,3
0712  120A  	BCF PCLATH,4
0713  2EEF  	GOTO	main

